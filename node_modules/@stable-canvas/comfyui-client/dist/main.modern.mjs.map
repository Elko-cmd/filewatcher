{"version":3,"file":"main.modern.mjs","sources":["../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js","../src/misc.ts","../src/ComfyUIWsClient.ts","../src/CachedFn.ts","../src/ComfyUIApiClient.ts","../src/InvokedWorkflow.ts","../src/ComfyUIWorkflow.ts","../src/ClientPlugin.ts","../src/plugins/LoginAuthPlugin.ts"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","export const uuidv4 = () =>\r\n  \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0,\r\n      v = c === \"x\" ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n\r\nexport const isNone = (x: any): x is null | undefined =>\r\n  x === null || x === undefined;\r\n","import { IComfyApiConfig } from \"./types\";\r\nimport { EventEmitter } from \"eventemitter3\";\r\nimport { ComfyUiWsTypes } from \"./ws.typs\";\r\nimport { uuidv4 } from \"./misc\";\r\n\r\ntype ComfyUIClientEvents = {\r\n  status: [ComfyUiWsTypes.Messages.Status[\"status\"] | null];\r\n  progress: [ComfyUiWsTypes.Messages.Progress];\r\n  executing: [ComfyUiWsTypes.Messages.Executing];\r\n  executed: [ComfyUiWsTypes.Messages.Executed];\r\n  execution_interrupted: [ComfyUiWsTypes.Messages.ExecutionInterrupted];\r\n\r\n  // this group events\r\n  execution_start: any;\r\n  execution_error: any;\r\n  execution_cached: any;\r\n\r\n  // this web client events\r\n  reconnected: any;\r\n  reconnecting: any;\r\n\r\n  /**\r\n   * load image data from websocket\r\n   */\r\n  image_data: [ArrayBuffer];\r\n\r\n  /**\r\n   * get all messages\r\n   */\r\n  message: any;\r\n\r\n  /**\r\n   * close client\r\n   */\r\n  close: any;\r\n\r\n  /**\r\n   * unhandled event message\r\n   */\r\n  unhandled: [{ type: string; data: any }];\r\n};\r\n\r\n/**\r\n * A client for interacting with the ComfyUI API server using WebSockets.\r\n *\r\n * NOTE: CORS policy: Request header field comfy-user is not allowed by Access-Control-Allow-Headers in preflight response. Please config.use empty string in browser.\r\n *\r\n * @example\r\n * ```typescript\r\n * const client = new ComfyUIWsClient({\r\n *  api_host: \"YOUR_API_HOST\"\r\n * });\r\n *\r\n * // Connect to the server\r\n * client.connect();\r\n *\r\n * // Listen for status updates\r\n * client.on(\"status\", (status) => {\r\n *   console.log(\"Status:\", status);\r\n * });\r\n *\r\n * // when done, close the client\r\n * client.close();\r\n */\r\nexport class ComfyUIWsClient {\r\n  static DEFAULT_API_HOST = \"127.0.0.1:8188\";\r\n  static DEFAULT_API_BASE = \"\";\r\n  static DEFAULT_USER = \"\";\r\n  static IS_BROWSER = typeof window !== \"undefined\";\r\n\r\n  static loadImageData(buf: ArrayBuffer) {\r\n    const view = new DataView(buf);\r\n    const eventType = view.getUint32(0);\r\n    switch (eventType) {\r\n      case 1:\r\n        const view2 = new DataView(buf);\r\n        const imageType = view2.getUint32(0);\r\n        let imageMime;\r\n        switch (imageType) {\r\n          case 1:\r\n          default:\r\n            imageMime = \"image/jpeg\";\r\n            break;\r\n          case 2:\r\n            imageMime = \"image/png\";\r\n        }\r\n        const image_buffer = buf.slice(8);\r\n        return image_buffer;\r\n        break;\r\n      default:\r\n        throw new Error(\r\n          `Unknown binary websocket message of type ${eventType}`\r\n        );\r\n    }\r\n  }\r\n\r\n  api_host: string;\r\n  api_base: string;\r\n  clientId?: string;\r\n  socket?: WebSocket | null;\r\n  WebSocket: typeof WebSocket;\r\n  ssl: boolean;\r\n  user: string;\r\n  fetch: typeof fetch;\r\n\r\n  events: EventEmitter<ComfyUIClientEvents & Record<string & {}, any>> =\r\n    new EventEmitter();\r\n\r\n  protected socket_callbacks: Record<string, any> = {};\r\n\r\n  get registered() {\r\n    return this.events.eventNames();\r\n  }\r\n\r\n  constructor(config: IComfyApiConfig) {\r\n    this.api_host = config.api_host ?? ComfyUIWsClient.DEFAULT_API_HOST;\r\n    this.api_base = config.api_base ?? ComfyUIWsClient.DEFAULT_API_BASE;\r\n    this.clientId = config.clientId ?? uuidv4();\r\n    this.WebSocket = config.WebSocket ?? globalThis.WebSocket;\r\n    this.ssl = config.ssl ?? false;\r\n    this.user = config.user ?? ComfyUIWsClient.DEFAULT_USER;\r\n    if (!globalThis.fetch) {\r\n      throw new Error(\"fetch is not defined\");\r\n    }\r\n    this.fetch = config.fetch ?? globalThis.fetch.bind(globalThis);\r\n\r\n    if (!this.WebSocket) {\r\n      console.warn(\"No WebSocket implementation available, WebSocket disabled\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the headers for the API request.\r\n   *\r\n   * @param {RequestInit} [options] - (Optional) Additional options for the request.\r\n   * @return {HeadersInit} The headers for the API request.\r\n   */\r\n  apiHeaders(options?: RequestInit) {\r\n    const headers: HeadersInit = {\r\n      ...(this.user\r\n        ? {\r\n            \"Comfy-User\": this.user,\r\n          }\r\n        : {}),\r\n      // \"User-Agent\": `ComfyUIClient/${version}`,\r\n      Accept: \"*/*\",\r\n      ...(options?.headers ?? {}),\r\n    };\r\n    return headers;\r\n  }\r\n\r\n  /**\r\n   * Generates the URL for the API endpoint based on the provided route.\r\n   *\r\n   * @param {string} route - The route for the API endpoint.\r\n   * @return {string} The generated URL for the API endpoint.\r\n   */\r\n  apiURL(route: string): string {\r\n    const url = new URL(`http${this.ssl ? \"s\" : \"\"}://${this.api_host}`);\r\n    let [pathname, query] = (this.api_base + route).split(\"?\");\r\n    url.pathname = pathname;\r\n    url.pathname = url.pathname.replace(/\\/+/g, \"/\");\r\n    if (query) {\r\n      url.search = query;\r\n    }\r\n    if (this.clientId) {\r\n      url.searchParams.set(\"clientId\", this.clientId);\r\n    }\r\n    return url.toString();\r\n  }\r\n\r\n  /**\r\n   * Generates a URL for viewing a specific file with the given filename, subfolder, and type.\r\n   *\r\n   * @param {string} filename - The name of the file to view.\r\n   * @param {string} subfolder - The subfolder where the file is located.\r\n   * @param {string} type - The type of the file.\r\n   * @return {string} The URL for viewing the file.\r\n   */\r\n  viewURL(filename: string, subfolder: string, type: string): string {\r\n    const query = new URLSearchParams({\r\n      filename,\r\n      subfolder,\r\n      type,\r\n    }).toString();\r\n    return `http${this.ssl ? \"s\" : \"\"}://${this.api_host}${\r\n      this.api_base\r\n    }/view?${query}`;\r\n  }\r\n\r\n  /**\r\n   * Generates the WebSocket URL based on the current API host and SSL configuration.\r\n   *\r\n   * @return {string} The generated WebSocket URL.\r\n   */\r\n  wsURL(): string {\r\n    const url = new URL(`ws${this.ssl ? \"s\" : \"\"}://${this.api_host}`);\r\n    url.pathname = \"/ws\";\r\n    if (this.clientId) {\r\n      url.searchParams.set(\"clientId\", this.clientId);\r\n    }\r\n    return url.toString();\r\n  }\r\n\r\n  /**\r\n   * Fetches API data based on the provided route and options.\r\n   *\r\n   * NOTE: CORS policy: Request header field comfy-user is not allowed by Access-Control-Allow-Headers in preflight response. Please use empty string in browser.\r\n   *\r\n   * @param {string} route - The route for the API request.\r\n   * @param {RequestInit} [options] - (Optional) Additional options for the request.\r\n   * @return {Promise<Response>} A promise that resolves to the API response.\r\n   */\r\n  async fetchApi(route: string, options?: RequestInit): Promise<Response> {\r\n    if (this.closed) {\r\n      throw new Error(\"Client is closed\");\r\n    }\r\n    const url = this.apiURL(route);\r\n    return this.fetch(url, {\r\n      ...options,\r\n      headers: this.apiHeaders(options),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener for the specified event type.\r\n   *\r\n   * @param {keyof ComfyUIClientEvents | (string & {})} type - The type of event to listen for.\r\n   * @param {(...args: any) => void} callback - The callback function to be executed when the event is triggered.\r\n   * @param {any} options - (Optional) Additional options for the event listener.\r\n   * @return {() => void} A function that removes the event listener when called.\r\n   */\r\n  addEventListener<T extends EventEmitter.EventNames<ComfyUIClientEvents>>(\r\n    type: T,\r\n    callback: EventEmitter.EventListener<ComfyUIClientEvents, T>,\r\n    options?: any\r\n  ) {\r\n    this.events.on(type as any, callback, options);\r\n\r\n    return () => {\r\n      this.events.off(type as any, callback);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener for the specified event type.\r\n   *\r\n   * @param {keyof ComfyUIClientEvents | (string & {})} type - The type of event to listen for.\r\n   * @param {(...args: any) => void} callback - The callback function to be executed when the event is triggered.\r\n   * @param {any} options - (Optional) Additional options for the event listener.\r\n   * @return {() => void} A function that removes the event listener when called.\r\n   */\r\n  on<T extends EventEmitter.EventNames<ComfyUIClientEvents>>(\r\n    type: T,\r\n    callback: EventEmitter.EventListener<ComfyUIClientEvents, T>,\r\n    options?: any\r\n  ) {\r\n    return this.addEventListener(type, callback, options);\r\n  }\r\n\r\n  protected _polling_timer: any = null;\r\n  protected _polling_interval = 1000;\r\n  /**\r\n   * Poll status for colab and other things that don't support websockets.\r\n   */\r\n  private startPollingQueue() {\r\n    if (this._polling_timer) {\r\n      return;\r\n    }\r\n    this._polling_timer = setInterval(async () => {\r\n      try {\r\n        const resp = await this.fetchApi(\"/prompt\");\r\n        const status = await resp.json();\r\n        this.events.emit(\"status\", status);\r\n      } catch (error) {\r\n        this.events.emit(\"status\", null);\r\n      }\r\n    }, this._polling_interval);\r\n  }\r\n\r\n  protected addSocketCallback<K extends keyof WebSocketEventMap>(\r\n    socket: WebSocket,\r\n    type: K,\r\n    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,\r\n    options?: boolean | AddEventListenerOptions\r\n  ) {\r\n    this.socket_callbacks[type] = listener;\r\n    socket.addEventListener(type, listener, options);\r\n    return () => {\r\n      delete this.socket_callbacks[type];\r\n      socket.removeEventListener(type, listener, options);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Removes all event listeners from the given WebSocket and clears the socket_callbacks object.\r\n   */\r\n  protected removeSocketCallbacks() {\r\n    if (this.socket) {\r\n      for (const type in this.socket_callbacks) {\r\n        const listener = this.socket_callbacks[type];\r\n        this.socket.removeEventListener(type, listener);\r\n      }\r\n    }\r\n    this.socket_callbacks = {};\r\n  }\r\n\r\n  /**\r\n   * Creates and connects a WebSocket for realtime updates\r\n   * @param {boolean} isReconnect If the socket is connection is a reconnect attempt\r\n   */\r\n  private createSocket(isReconnect = false) {\r\n    if (this.socket) {\r\n      return;\r\n    }\r\n    if (!this.WebSocket) {\r\n      throw new Error(\r\n        \"WebSocket is not defined, please provide a WebSocket implementation\"\r\n      );\r\n    }\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n\r\n    let opened = false;\r\n\r\n    this.socket = new this.WebSocket(this.wsURL());\r\n    this.socket.binaryType = \"arraybuffer\";\r\n\r\n    this.addSocketCallback(this.socket, \"open\", () => {\r\n      opened = true;\r\n      if (isReconnect) {\r\n        this.events.emit(\"reconnected\");\r\n      }\r\n    });\r\n\r\n    this.addSocketCallback(this.socket, \"error\", () => {\r\n      if (this.socket) this.socket.close();\r\n      if (!isReconnect && !opened) {\r\n        this.startPollingQueue();\r\n      }\r\n    });\r\n\r\n    this.addSocketCallback(this.socket, \"close\", () => {\r\n      setTimeout(() => {\r\n        this.socket = null;\r\n        this.createSocket(true);\r\n      }, 300);\r\n      if (opened) {\r\n        this.events.emit(\"status\", null);\r\n        this.events.emit(\"reconnecting\");\r\n      }\r\n    });\r\n\r\n    const isImageMessage = (event: MessageEvent) => {\r\n      if (typeof event.data === \"string\") {\r\n        return false;\r\n      }\r\n      if (ComfyUIWsClient.IS_BROWSER) {\r\n        return event.data instanceof Blob;\r\n      }\r\n      if (ArrayBuffer && event.data instanceof ArrayBuffer) {\r\n        return true;\r\n      }\r\n      if (Buffer && Buffer.isBuffer(event.data)) {\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n\r\n    this.addSocketCallback(this.socket, \"message\", (event) => {\r\n      this.events.emit(\"message\", event);\r\n\r\n      if (isImageMessage(event)) {\r\n        const image = ComfyUIWsClient.loadImageData(event.data);\r\n        this.events.emit(\"image_data\", image);\r\n      } else {\r\n        const msg = JSON.parse(event.data);\r\n\r\n        switch (msg.type) {\r\n          case \"status\":\r\n            if (msg.data.sid) {\r\n              this.clientId = msg.data.sid;\r\n            }\r\n            this.events.emit(\"status\", msg.data.status);\r\n            break;\r\n          case \"progress\":\r\n            this.events.emit(\"progress\", msg.data);\r\n            break;\r\n          case \"executing\":\r\n            this.events.emit(\"executing\", msg.data);\r\n            break;\r\n          case \"executed\":\r\n            this.events.emit(\"executed\", msg.data);\r\n            break;\r\n          case \"execution_start\":\r\n            this.events.emit(\"execution_start\", msg.data);\r\n            break;\r\n          case \"execution_error\":\r\n            this.events.emit(\"execution_error\", msg.data);\r\n            break;\r\n          case \"execution_cached\":\r\n            this.events.emit(\"execution_cached\", msg.data);\r\n            break;\r\n          case \"execution_interrupted\":\r\n            this.events.emit(\"execution_interrupted\", msg.data);\r\n            break;\r\n          default:\r\n            this.events.emit(msg.type, msg.data);\r\n            break;\r\n        }\r\n\r\n        const is_unhandled_message =\r\n          this.registered.includes(msg.type) === false;\r\n        if (is_unhandled_message) {\r\n          this.events.emit(\"unhandled\", msg);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initializes sockets and realtime updates\r\n   *\r\n   * @deprecated move to client.connect()\r\n   */\r\n  init() {\r\n    this.createSocket();\r\n  }\r\n\r\n  closed = false;\r\n  /**\r\n   * Closes the WebSocket connection and cleans up event listeners\r\n   */\r\n  close() {\r\n    if (this.closed) {\r\n      return;\r\n    }\r\n    this.closed = true;\r\n    this.events.emit(\"close\");\r\n\r\n    this.disconnect();\r\n    this.events.removeAllListeners();\r\n  }\r\n\r\n  /**\r\n   * Connects to the WebSocket server by creating a new socket connection.\r\n   *\r\n   * @param {Object} options - The options for connecting to the server.\r\n   * @param {Object} options.polling - The options for polling.\r\n   * @param {boolean} options.polling.enabled - Whether polling is enabled.\r\n   * @param {number} [options.polling.interval] - The interval for polling.\r\n   * @param {Object} options.websocket - The options for the WebSocket connection.\r\n   * @param {boolean} options.websocket.enabled - Whether the WebSocket connection is enabled.\r\n   * @return {this} - The instance of the class.\r\n   */\r\n  connect({\r\n    polling = {\r\n      enabled: false,\r\n    },\r\n    websocket = {\r\n      enabled: true,\r\n    },\r\n  }: {\r\n    polling?: {\r\n      enabled: boolean;\r\n      interval?: number;\r\n    };\r\n    websocket?: {\r\n      enabled: boolean;\r\n    };\r\n  } = {}) {\r\n    if (polling?.enabled) {\r\n      this._polling_interval = polling.interval ?? this._polling_interval;\r\n      this.startPollingQueue();\r\n    }\r\n    if (websocket?.enabled) {\r\n      this.createSocket();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Disconnects the WebSocket connection and cleans up event listeners.\r\n   */\r\n  disconnect() {\r\n    if (!this.socket) {\r\n      process.nextTick(this._disconnectPolling.bind(this));\r\n    } else {\r\n      this._disconnectSocket();\r\n    }\r\n    this._disconnectPolling();\r\n  }\r\n\r\n  /**\r\n   * Disconnects the WebSocket connection and cleans up event listeners.\r\n   *\r\n   * @return {void} This function does not return anything.\r\n   */\r\n  _disconnectSocket() {\r\n    const { socket } = this;\r\n    if (!socket) return;\r\n    this.socket = null;\r\n    try {\r\n      if (socket.readyState === socket.OPEN) {\r\n        socket.close(1000, \"Client closed\");\r\n      }\r\n    } catch (error) {\r\n      // pass\r\n    }\r\n    this.removeSocketCallbacks();\r\n    if (\"removeAllListeners\" in socket) {\r\n      (socket.removeAllListeners as any)?.();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnects the polling timer and sets it to null.\r\n   *\r\n   * @return {void}\r\n   */\r\n  _disconnectPolling() {\r\n    if (this._polling_timer !== null) {\r\n      clearInterval(this._polling_timer);\r\n      this._polling_timer = null;\r\n    }\r\n  }\r\n}\r\n","export type CachedFnOptions = {\r\n  expire_time?: number;\r\n  enabled?: boolean;\r\n};\r\n\r\nclass GlobalCacheHub {\r\n  static KEY = \"__COMFY_UI_CLIENT_CACHE__\";\r\n  protected _cached: Map<string, { result: any; expire: number }>;\r\n\r\n  constructor() {\r\n    this._cached = (globalThis as any)[GlobalCacheHub.KEY] || new Map();\r\n    (globalThis as any)[GlobalCacheHub.KEY] = this._cached;\r\n  }\r\n\r\n  clear() {\r\n    this._cached.clear();\r\n  }\r\n\r\n  get(key: string) {\r\n    return this._cached.get(key);\r\n  }\r\n\r\n  set(key: string, value: { result: any; expire: number }) {\r\n    this._cached.set(key, value);\r\n  }\r\n}\r\n\r\nexport class CachedFn {\r\n  static _defaultExpire: number = 60 * 1000;\r\n\r\n  protected expire_time_ms: number;\r\n  protected enabled: boolean;\r\n\r\n  protected _cached = new GlobalCacheHub();\r\n\r\n  protected cache_ns: string = \"\";\r\n\r\n  constructor(ns: string, options?: CachedFnOptions) {\r\n    this.expire_time_ms = options?.expire_time ?? CachedFn._defaultExpire;\r\n    this.enabled = options?.enabled ?? true;\r\n    this.cache_ns = ns;\r\n  }\r\n\r\n  public reset() {\r\n    this._cached.clear();\r\n  }\r\n\r\n  private _hashArgs(args: any[]): string {\r\n    try {\r\n      return JSON.stringify(args);\r\n    } catch (error) {\r\n      return args.toString();\r\n    }\r\n  }\r\n\r\n  public warp<ARGS extends any[], RET>(\r\n    key: string,\r\n    fn: (...args: ARGS) => RET\r\n  ): (...args: ARGS) => RET {\r\n    if (!this.enabled) {\r\n      return fn;\r\n    }\r\n    return (...args: ARGS) => {\r\n      const now = Date.now();\r\n      const argsHash = this._hashArgs(args);\r\n      const cacheKey = `${this.cache_ns}:${key}:${argsHash}`;\r\n      const hit_cached = this._cached.get(cacheKey);\r\n\r\n      if (hit_cached && hit_cached.expire > now) {\r\n        return hit_cached.result;\r\n      }\r\n\r\n      const result = fn(...args);\r\n      this._cached.set(cacheKey, { result, expire: now + this.expire_time_ms });\r\n      return result;\r\n    };\r\n  }\r\n}\r\n","import { CachedFn } from \"./CachedFn\";\r\nimport type { ClientPlugin } from \"./ClientPlugin\";\r\nimport { ComfyUIWsClient } from \"./ComfyUIWsClient\";\r\nimport { isNone } from \"./misc\";\r\nimport { ComfyUIClientResponseTypes } from \"./response.types\";\r\nimport { IComfyApiConfig, WorkflowOutput } from \"./types\";\r\nimport { ComfyUiWsTypes } from \"./ws.typs\";\r\n\r\n/**\r\n * The ComfyUIApiClient class provides a high-level interface for interacting with the ComfyUI API.\r\n *\r\n * @extends ComfyUIWsClient\r\n *\r\n * @example\r\n * ```typescript\r\n * const client = new ComfyUIApiClient({\r\n *  api_host: \"YOUR_API_HOST\",\r\n *  clientId: \"YOUR_CLIENT_ID\",\r\n * });\r\n *\r\n * const extensions = await client.getEmbeddings();\r\n * console.log(extensions);\r\n * ```\r\n */\r\nexport class ComfyUIApiClient extends ComfyUIWsClient {\r\n  private _cached_fn: CachedFn;\r\n\r\n  // NOTE: useless ... just for debug\r\n  private _plugins = [] as ClientPlugin[];\r\n\r\n  constructor(config: IComfyApiConfig) {\r\n    super(config);\r\n\r\n    const cache_ns = `${config.api_host}`;\r\n    this._cached_fn = new CachedFn(cache_ns, config.cache);\r\n  }\r\n\r\n  /**\r\n   * Use a plugin by calling its install method on this instance.\r\n   *\r\n   * @param {ClientPlugin} plugin - The plugin to install.\r\n   */\r\n  use(plugin: ClientPlugin) {\r\n    plugin.install(this);\r\n    this._plugins.push(plugin);\r\n  }\r\n\r\n  /**\r\n   * Gets a list of extension urls\r\n   * @returns An array of script urls to import\r\n   */\r\n  async getExtensions(): Promise<string[]> {\r\n    const invoke = async () => {\r\n      const resp = await this.fetchApi(\"/extensions\", { cache: \"no-store\" });\r\n      return await resp.json();\r\n    };\r\n    const cached = this._cached_fn.warp(\"extensions\", invoke);\r\n    return cached();\r\n  }\r\n\r\n  /**\r\n   * Gets a list of embedding names\r\n   * @returns An array of script urls to import\r\n   */\r\n  async getEmbeddings(): Promise<string[]> {\r\n    const invoke = async () => {\r\n      const resp = await this.fetchApi(\"/embeddings\", { cache: \"no-store\" });\r\n      return await resp.json();\r\n    };\r\n    const cached = this._cached_fn.warp(\"embeddings\", invoke);\r\n    return cached();\r\n  }\r\n\r\n  /**\r\n   * Loads node object definitions for the graph\r\n   * @returns {Promise<ComfyUIClientResponseTypes.ObjectInfo>} The object info for the graph\r\n   */\r\n  async getNodeDefs(): Promise<ComfyUIClientResponseTypes.ObjectInfo> {\r\n    const invoke = async () => {\r\n      const resp = await this.fetchApi(\"/object_info\", { cache: \"no-store\" });\r\n      const node_defs = await resp.json();\r\n      return node_defs;\r\n    };\r\n    const cached = this._cached_fn.warp(\"object_info\", invoke);\r\n    return cached();\r\n  }\r\n\r\n  /**\r\n   * Clears the node object definitions cache\r\n   */\r\n  resetCache() {\r\n    this._cached_fn.reset();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} queue_index The index at which to queue the prompt, passing -1 will insert the prompt at the front of the queue\r\n   * @param {Object} options\r\n   * @param {Object} options.prompt The prompt to queue\r\n   * @param {Object} options.workflow This png info to be added to resulting image\r\n   * @returns {Promise<ComfyUIClientResponseTypes.QueuePrompt>} The response from the server\r\n   */\r\n  async queuePrompt(\r\n    queue_index: number,\r\n    { prompt, workflow }: { prompt: any; workflow: any }\r\n  ): Promise<ComfyUIClientResponseTypes.QueuePrompt> {\r\n    const body: Record<string, unknown> = {\r\n      client_id: this.clientId,\r\n      prompt,\r\n      extra_data: { extra_pnginfo: { workflow } },\r\n    };\r\n\r\n    if (queue_index === -1) {\r\n      body.front = true;\r\n    } else if (queue_index !== 0) {\r\n      body.number = queue_index;\r\n    }\r\n\r\n    const res = await this.fetchApi(\"/prompt\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify(body),\r\n    });\r\n\r\n    if (res.status !== 200) {\r\n      const error_resp = await res.text();\r\n      try {\r\n        const error_data = JSON.parse(error_resp);\r\n        // TODO throw Error class\r\n        throw { response: error_data };\r\n      } catch (error) {\r\n        throw { response: error_resp };\r\n      }\r\n    }\r\n\r\n    return await res.json();\r\n  }\r\n\r\n  /**\r\n   * Loads a list of items (queue or history)\r\n   * @param {\"queue\" | \"history\"} type The type of items to load, queue or history\r\n   * @returns The items of the specified type grouped by their status\r\n   */\r\n  async getItems(type: \"history\"): ReturnType<ComfyUIApiClient[\"getHistory\"]>;\r\n  async getItems(type: \"queue\"): ReturnType<ComfyUIApiClient[\"getQueue\"]>;\r\n  async getItems(type: \"queue\" | \"history\"): Promise<any> {\r\n    if (type === \"queue\") {\r\n      return this.getQueue();\r\n    }\r\n    return this.getHistory();\r\n  }\r\n\r\n  /**\r\n   * Gets the current state of the queue\r\n   * @returns The currently running and queued items\r\n   */\r\n  async getQueue(): Promise<{\r\n    Running: Array<Record<string, unknown>>;\r\n    Pending: Array<Record<string, unknown>>;\r\n  }> {\r\n    try {\r\n      const res = await this.fetchApi(\"/queue\");\r\n      const data = await res.json();\r\n      return {\r\n        Running: data.queue_running.map((prompt: any) => ({\r\n          prompt,\r\n          remove: { name: \"Cancel\", cb: () => this.interrupt() },\r\n        })),\r\n        Pending: data.queue_pending.map((prompt: any) => ({ prompt })),\r\n      };\r\n    } catch (error) {\r\n      console.error(error);\r\n      return { Running: [], Pending: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the prompt execution history\r\n   * @returns Prompt history including node outputs\r\n   */\r\n  async getHistory(max_items = 200): Promise<{\r\n    History: Array<{\r\n      // [index, prompt_id, prompt, payload, outputs_node]\r\n      prompt: [number, string, any, any, any];\r\n      outputs: Record<string, unknown>;\r\n      status: {\r\n        status_str: string;\r\n        completed: boolean;\r\n        messages: any[];\r\n      };\r\n    }>;\r\n  }> {\r\n    try {\r\n      const res = await this.fetchApi(`/history?max_items=${max_items}`);\r\n      return { History: Object.values(await res.json()) };\r\n    } catch (error) {\r\n      console.error(error);\r\n      return { History: [] };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets system & device stats\r\n   * @returns {ComfyUIClientResponseTypes.SystemStatsRoot} System stats such as python version, OS, per device info\r\n   */\r\n\r\n  async getSystemStats(): Promise<ComfyUIClientResponseTypes.SystemStatsRoot> {\r\n    const res = await this.fetchApi(\"/system_stats\");\r\n    return res.json();\r\n  }\r\n\r\n  /**\r\n   * Sends a POST request to the API\r\n   * @param {\"queue\" | \"history\"} type The endpoint to post to\r\n   * @param {any} body Optional POST data\r\n   */\r\n  private async postApi(type: string, body: any) {\r\n    await this.fetchApi(\"/\" + type, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: body ? JSON.stringify(body) : undefined,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes an item from the specified list\r\n   * @param {\"queue\" | \"history\"} type The type of item to delete, queue or history\r\n   * @param {any} id The id of the item to delete\r\n   */\r\n  async deleteItem(type: \"queue\" | \"history\", id: any) {\r\n    await this.postApi(type, { delete: [id] });\r\n  }\r\n\r\n  /**\r\n   * Clears the specified list\r\n   * @param {\"queue\" | \"history\"} type The type of list to clear, queue or history\r\n   */\r\n  async clearItems(type: \"queue\" | \"history\") {\r\n    await this.postApi(type, { clear: true });\r\n  }\r\n\r\n  /**\r\n   * Interrupts the execution of the running prompt\r\n   */\r\n  async interrupt() {\r\n    await this.postApi(\"interrupt\", null);\r\n  }\r\n\r\n  /**\r\n   * Free up memory by unloading models and freeing memory\r\n   */\r\n  async free(params?: { unload_models?: boolean; free_memory?: boolean }) {\r\n    await this.postApi(\"free\", params);\r\n  }\r\n\r\n  /**\r\n   * Gets user configuration data and where data should be stored\r\n   * @returns { Promise<{ storage: \"server\" | \"browser\", users?: Promise<string, unknown>, migrated?: boolean }> }\r\n   */\r\n  async getUserConfig() {\r\n    return (await this.fetchApi(\"/users\")).json();\r\n  }\r\n\r\n  /**\r\n   * Creates a new user\r\n   * @param { string } username\r\n   * @returns The fetch response\r\n   */\r\n  async createUser(username: string): Promise<Response> {\r\n    return this.fetchApi(\"/users\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({ username }),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets all setting values for the current user\r\n   * @returns { Promise<string, unknown> } A dictionary of id -> value\r\n   */\r\n  async getSettings(): Promise<Record<string, unknown>> {\r\n    return (await this.fetchApi(\"/settings\")).json();\r\n  }\r\n\r\n  /**\r\n   * Gets a setting for the current user\r\n   * @param { string } id The id of the setting to fetch\r\n   * @returns { Promise<unknown> } The setting value\r\n   */\r\n  async getSetting(id: string): Promise<unknown> {\r\n    return (await this.fetchApi(`/settings/${encodeURIComponent(id)}`)).json();\r\n  }\r\n\r\n  /**\r\n   * Stores a dictionary of settings for the current user\r\n   * @param { Record<string, unknown> } settings Dictionary of setting id -> value to save\r\n   * @returns { Promise<void> }\r\n   */\r\n  async storeSettings(settings: Record<string, unknown>): Promise<Response> {\r\n    return this.fetchApi(`/settings`, {\r\n      method: \"POST\",\r\n      body: JSON.stringify(settings),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Stores a setting for the current user\r\n   * @param { string } id The id of the setting to update\r\n   * @param { unknown } value The value of the setting\r\n   * @returns { Promise<void> }\r\n   */\r\n  async storeSetting(id: string, value: unknown): Promise<Response> {\r\n    return this.fetchApi(`/settings/${encodeURIComponent(id)}`, {\r\n      method: \"POST\",\r\n      body: JSON.stringify(value),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets a user data file for the current user\r\n   * @param { string } file The name of the userdata file to load\r\n   * @param { RequestInit } [options]\r\n   * @returns { Promise<unknown> } The fetch response object\r\n   */\r\n  async getUserData(file: string, options?: RequestInit): Promise<Response> {\r\n    return this.fetchApi(`/userdata/${encodeURIComponent(file)}`, options);\r\n  }\r\n\r\n  /**\r\n   * Stores a user data file for the current user\r\n   * @param { string } file The name of the userdata file to save\r\n   * @param { any } data The data to save to the file\r\n   * @param { RequestInit & { stringify?: boolean, throwOnError?: boolean } } [options]\r\n   * @returns { Promise<void> }\r\n   */\r\n  async storeUserData(\r\n    file: string,\r\n    data: any,\r\n    options?: RequestInit & { stringify?: boolean; throwOnError?: boolean }\r\n  ): Promise<void> {\r\n    const resp = await this.fetchApi(`/userdata/${encodeURIComponent(file)}`, {\r\n      method: \"POST\",\r\n      body: options?.stringify ? JSON.stringify(data) : data,\r\n      ...options,\r\n    });\r\n    if (resp.status !== 200) {\r\n      const error = await resp.text();\r\n      throw new Error(\r\n        `Error storing user data file '${file}': ${resp.status} ${error}`\r\n      );\r\n    }\r\n  }\r\n\r\n  // ----------------- get status ++ -----------------\r\n\r\n  /**\r\n   * Retrieves the list of samplers from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the sampler names.\r\n   */\r\n  async getSamplers() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find KSampler node\r\n    const node = node_config[\"KSampler\"];\r\n    const sampler_name = node?.input?.required?.[\"sampler_name\"]?.[0] || [];\r\n    return sampler_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of schedulers from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the scheduler names.\r\n   */\r\n  async getSchedulers() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find Scheduler node\r\n    const node = node_config[\"KSampler\"];\r\n    const scheduler_name = node?.input?.required?.[\"scheduler\"]?.[0] || [];\r\n    return scheduler_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of model names from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.\r\n   */\r\n  async getSDModels() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find CheckpointLoaderSimple node\r\n    const node = node_config[\"CheckpointLoaderSimple\"];\r\n    const model_name = node?.input?.required?.[\"ckpt_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of model names from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.\r\n   */\r\n  async getCNetModels() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find ControlNetLoader node\r\n    const node = node_config[\"ControlNetLoader\"];\r\n    const model_name = node?.input?.required?.[\"control_net_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of model names from the node definitions for the UpscaleModelLoader node.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.\r\n   */\r\n  async getUpscaleModels() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find UpscaleModelLoader node\r\n    const node = node_config[\"UpscaleModelLoader\"];\r\n    const model_name = node?.input?.required?.[\"model_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of hypernetwork names from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the hypernetwork names.\r\n   */\r\n  async getHyperNetworks() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find HypernetworkLoader node\r\n    const node = node_config[\"HypernetworkLoader\"];\r\n    const model_name = node?.input?.required?.[\"hypernetwork_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of LoRAs from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the LoRAs.\r\n   */\r\n  async getLoRAs() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find LoraLoader node\r\n    const node = node_config[\"LoraLoader\"];\r\n    const model_name = node?.input?.required?.[\"lora_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  /**\r\n   * Retrieves the list of VAE names from the node definitions.\r\n   *\r\n   * @return {Promise<string[]>} A promise that resolves to an array of strings representing the VAE names.\r\n   */\r\n  async getVAEs() {\r\n    const node_config = await this.getNodeDefs();\r\n    // find VAELoader node\r\n    const node = node_config[\"VAELoader\"];\r\n    const model_name = node?.input?.required?.[\"vae_name\"]?.[0] || [];\r\n    return model_name as string[];\r\n  }\r\n\r\n  // ----------------- Prompt ++ -----------------\r\n\r\n  /**\r\n   * Retrieves the status of a prompt based on the provided prompt ID.\r\n   *\r\n   * @param {string} prompt_id - The ID of the prompt to check status for.\r\n   * @return {Object} Object containing the running, pending, and done status of the prompt.\r\n   */\r\n  async getPromptStatus(prompt_id: string) {\r\n    const { Running, Pending } = await this.getQueue();\r\n    const running = Running.some(\r\n      (task: any) => task?.prompt?.[1] === prompt_id\r\n    );\r\n    const pending = Pending.some(\r\n      (task: any) => task?.prompt?.[1] === prompt_id\r\n    );\r\n    const done = !running && !pending;\r\n    return {\r\n      running,\r\n      pending,\r\n      done,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Retrieves the outputs of a prompt with the given ID from the history.\r\n   *\r\n   * @param {string} prompt_id - The ID of the prompt to retrieve the outputs for.\r\n   * @return {Promise<any>} A promise that resolves to the outputs of the prompt.\r\n   * @throws {Error} If the prompt with the given ID is not found in the history or if it failed with a non-\"success\" status.\r\n   */\r\n  async getPromptOutputs(prompt_id: string) {\r\n    const { History: history } = await this.getHistory();\r\n    const item = history.find((item) => item.prompt[1] === prompt_id);\r\n    if (!item) {\r\n      throw new Error(`Prompt [${prompt_id}] not found in history`);\r\n    }\r\n\r\n    const status = item.status.status_str;\r\n    if (status !== \"success\") {\r\n      throw new Error(`Prompt [${prompt_id}] failed with status: ${status}`);\r\n    }\r\n\r\n    return item.outputs;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the result of a prompt based on the provided prompt ID.\r\n   *\r\n   * @param {string} prompt_id - The ID of the prompt to retrieve the result for.\r\n   * @return {WorkflowOutput} An object containing the images associated with the prompt and the prompt ID.\r\n   */\r\n  async getPromptImageResult(prompt_id: string): Promise<WorkflowOutput> {\r\n    const outputs = await this.getPromptOutputs(prompt_id);\r\n\r\n    // find image from history\r\n    const images: {\r\n      filename?: string;\r\n      subfolder?: string;\r\n      type: string;\r\n    }[] = Object.values(outputs).flatMap((node_output) => {\r\n      return (node_output as any).images || [];\r\n    });\r\n    const images_url = images\r\n      .map((image) => {\r\n        const { filename, subfolder, type } = image;\r\n        if (isNone(filename) || isNone(subfolder) || type !== \"output\") {\r\n          return null;\r\n        }\r\n        return this.viewURL(filename, subfolder, type);\r\n      })\r\n      .filter(Boolean) as string[];\r\n    return {\r\n      images: images_url.map((data) => ({ type: \"url\", data })),\r\n      prompt_id,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Asynchronously waits for the prompt with the provided ID to be done.\r\n   *\r\n   * @param {string} prompt_id - The ID of the prompt to wait for.\r\n   * @param {number} [polling_ms=1000] - The number of milliseconds to wait between checks.\r\n   * @return {void}\r\n   */\r\n  async waitForPrompt(prompt_id: string, polling_ms = 1000) {\r\n    let prompt_status = await this.getPromptStatus(prompt_id);\r\n    while (!prompt_status.done) {\r\n      await new Promise((resolve) => setTimeout(resolve, polling_ms));\r\n      prompt_status = await this.getPromptStatus(prompt_id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously waits for the prompt with the provided ID to be done using WebSocket.\r\n   *\r\n   * @param {string} prompt_id - The ID of the prompt to wait for.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves to a WorkflowOutput object containing the images and prompt_id.\r\n   */\r\n  async waitForPromptWebSocket(prompt_id: string) {\r\n    const output: WorkflowOutput = {\r\n      images: [],\r\n      prompt_id,\r\n    };\r\n    return new Promise<WorkflowOutput>((resolve, reject) => {\r\n      let done = false;\r\n      const offEvent2 = this.on(\"image_data\", (data) => {\r\n        output.images.push({ type: \"buff\", data });\r\n      });\r\n      const offEvent = this.on(\"executed\", (data) => {\r\n        const { prompt_id: current_prompt_id, output: executed_output } = data;\r\n        if (current_prompt_id !== prompt_id) {\r\n          return;\r\n        }\r\n        done = true;\r\n        const { images = [] } = executed_output || {};\r\n\r\n        // collect url images\r\n        for (const image of images) {\r\n          const { filename, subfolder, type } = image || {};\r\n          if (isNone(filename) || isNone(subfolder) || type !== \"output\") {\r\n            continue;\r\n          }\r\n          output.images.push({\r\n            type: \"url\",\r\n            data: this.viewURL(filename, subfolder, type),\r\n          });\r\n        }\r\n\r\n        resolve(output);\r\n        offEvent();\r\n        offEvent2();\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Randomizes the seed value of nodes with class type \"KSampler\" in the prompt.\r\n   *\r\n   * @param {Record<string, unknown>} prompt - The prompt object to randomize.\r\n   * @return {void}\r\n   */\r\n  randomizePrompt(prompt: Record<string, unknown>) {\r\n    for (const node of Object.values(prompt) as any[]) {\r\n      if (node.class_type === \"KSampler\") {\r\n        // python random seed is 32 bit\r\n        node.inputs.seed = Math.floor(Math.random() * (2 ** 32 - 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Asynchronously enqueues a prompt with optional workflow and random seed.\r\n   *\r\n   * @param {Record<string, unknown>} prompt - The prompt to enqueue.\r\n   * @param {Object} [options] - The options for enqueueing the prompt.\r\n   * @param {Record<string, unknown>} [options.workflow] - The workflow for the prompt.\r\n   * @param {boolean} [options.disable_random_seed=false] - Whether to disable random seed.\r\n   * @return {Promise<{ prompt_id: string; number: number; node_errors: any; }>} A promise that resolves with the enqueued prompt response.\r\n   * @throws {Error} If there is an error in the response.\r\n   */\r\n  async _enqueue_prompt(\r\n    prompt: Record<string, unknown>,\r\n    options?: {\r\n      workflow?: Record<string, unknown>;\r\n      disable_random_seed?: boolean;\r\n    }\r\n  ) {\r\n    if (!options?.disable_random_seed) {\r\n      this.randomizePrompt(prompt);\r\n    }\r\n    const resp = await this.queuePrompt(0, {\r\n      prompt,\r\n      workflow: options?.workflow,\r\n    });\r\n    if (\"error\" in resp) {\r\n      // TODO new Error class\r\n      throw new Error(resp.error);\r\n    }\r\n    return resp;\r\n  }\r\n\r\n  /**\r\n   * Asynchronously runs a prompt with the provided options.\r\n   *\r\n   * This function does not use WebSocket, but uses polling to get the result\r\n   * So if your workflow contains custom ws events, this function will not be able to get these events\r\n   *\r\n   * @param {Record<string, unknown>} prompt - The prompt to run.\r\n   * @param {Object} options - The options for running the prompt.\r\n   * @param {Record<string, unknown>} options.workflow - The workflow for the prompt, It will be added to the png info of the generated image.\r\n   * @param {boolean} [options.disable_random_seed] - Flag to disable random seed generation.\r\n   * @param {number} [options.polling_ms=1000] - The number of milliseconds to polling query prompt result.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.\r\n   *\r\n   * @deprecated Use `enqueue_polling` instead\r\n   */\r\n  async runPrompt(\r\n    prompt: Record<string, unknown>,\r\n    options?: {\r\n      workflow?: Record<string, unknown>;\r\n      disable_random_seed?: boolean;\r\n      polling_ms?: number;\r\n    }\r\n  ) {\r\n    const resp = await this._enqueue_prompt(prompt, options);\r\n    const prompt_id = resp.prompt_id;\r\n    await this.waitForPrompt(prompt_id, options?.polling_ms);\r\n    return await this.getPromptImageResult(prompt_id);\r\n  }\r\n\r\n  /**\r\n   * Asynchronously runs a prompt with the provided options.\r\n   *\r\n   * This function does not use WebSocket, but uses polling to get the result\r\n   * So if your workflow contains custom ws events, this function will not be able to get these events\r\n   *\r\n   * @param {Record<string, unknown>} prompt - The prompt to run.\r\n   * @param {Object} options - The options for running the prompt.\r\n   * @param {Record<string, unknown>} options.workflow - The workflow for the prompt, It will be added to the png info of the generated image.\r\n   * @param {boolean} [options.disable_random_seed] - Flag to disable random seed generation.\r\n   * @param {number} [options.polling_ms=1000] - The number of milliseconds to polling query prompt result.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.\r\n   */\r\n  async enqueue_polling(\r\n    prompt: Record<string, unknown>,\r\n    options?: {\r\n      workflow?: Record<string, unknown>;\r\n      disable_random_seed?: boolean;\r\n      polling_ms?: number;\r\n    }\r\n  ) {\r\n    const resp = await this._enqueue_prompt(prompt, options);\r\n    const prompt_id = resp.prompt_id;\r\n    await this.waitForPrompt(prompt_id, options?.polling_ms);\r\n    return await this.getPromptImageResult(prompt_id);\r\n  }\r\n\r\n  /**\r\n   * Enqueues a prompt and waits for the corresponding prompt websocket.\r\n   *\r\n   * @param {Record<string, unknown>} prompt - The prompt to enqueue.\r\n   * @param {{ workflow?: Record<string, unknown>; disable_random_seed?: boolean; }} [options] - The options for enqueueing the prompt.\r\n   * @param {Record<string, unknown>} [options.workflow] - This data for PNG info.\r\n   * @param {boolean} [options.disable_random_seed] - Whether to disable random seed.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.\r\n   */\r\n  async enqueue(\r\n    prompt: Record<string, unknown>,\r\n    options?: {\r\n      /**\r\n       * this data for PNG info\r\n       */\r\n      workflow?: Record<string, unknown>;\r\n      disable_random_seed?: boolean;\r\n      progress?: (p: ComfyUiWsTypes.Messages.Progress) => void;\r\n    }\r\n  ) {\r\n    const resp = await this._enqueue_prompt(prompt, options);\r\n    const prompt_id = resp.prompt_id;\r\n\r\n    let off: any;\r\n    if (options?.progress) {\r\n      off = this.on(\"progress\", (_data) => {\r\n        const data = {\r\n          // old api response type:\r\n          ...(\"progress\" in _data ? { ...(_data as any).progress } : {}),\r\n          // new api: https://github.com/StableCanvas/comfyui-client/issues/6\r\n          ..._data,\r\n        };\r\n        if (data.prompt_id === prompt_id) {\r\n          options?.progress?.(data);\r\n        }\r\n      });\r\n    }\r\n    try {\r\n      return await this.waitForPromptWebSocket(prompt_id);\r\n    } finally {\r\n      off?.();\r\n    }\r\n  }\r\n}\r\n","import { ComfyUIApiClient } from \"./ComfyUIApiClient\";\r\nimport { isNone } from \"./misc\";\r\nimport type { WorkflowOutput, IWorkflow } from \"./types\";\r\n\r\nexport class InvokedWorkflow {\r\n  protected _task_id?: Promise<string>;\r\n  protected _enqueue_req?: ReturnType<ComfyUIApiClient[\"_enqueue_prompt\"]>;\r\n\r\n  protected _result: WorkflowOutput = {\r\n    images: [],\r\n    prompt_id: \"\",\r\n  };\r\n\r\n  executed = false;\r\n\r\n  constructor(public workflow: IWorkflow, public client: ComfyUIApiClient) {}\r\n\r\n  public enqueue() {\r\n    const { prompt, workflow: wf } = this.workflow;\r\n    this._enqueue_req = this.client._enqueue_prompt(prompt, { workflow: wf });\r\n    this._task_id = this._enqueue_req.then((data) => data.prompt_id);\r\n\r\n    this._enqueue_req.then((data) => {\r\n      this._result.prompt_id = data.prompt_id;\r\n    });\r\n  }\r\n\r\n  protected load_result_data(data: any) {\r\n    const { output: executed_output } = data;\r\n    const { images = [] } = executed_output || {};\r\n\r\n    // collect url images\r\n    for (const image of images) {\r\n      const { filename, subfolder, type } = image || {};\r\n      if (isNone(filename) || isNone(subfolder) || type !== \"output\") {\r\n        continue;\r\n      }\r\n      this._result.images.push({\r\n        type: \"url\",\r\n        data: this.client.viewURL(filename, subfolder, type),\r\n      });\r\n    }\r\n  }\r\n\r\n  public async query() {\r\n    if (!this._task_id) {\r\n      throw new Error(\r\n        \"This workflow is not enqueued and the execution status cannot be queried\"\r\n      );\r\n    }\r\n    return this.client.getPromptStatus(await this._task_id);\r\n  }\r\n\r\n  public async interrupt() {\r\n    if (!this._task_id) {\r\n      throw new Error(\r\n        \"This workflow is not enqueued and the execution status cannot be interrupt\"\r\n      );\r\n    }\r\n    const id = await this._task_id;\r\n    const { pending, running, done } = await this.query();\r\n    if (done) return;\r\n    if (pending) {\r\n      this.client.deleteItem(\"queue\", id);\r\n      return;\r\n    }\r\n    if (running) {\r\n      return this.client.interrupt();\r\n    }\r\n    throw new Error(`wrong task status, id: ${id}`);\r\n  }\r\n\r\n  public async wait() {\r\n    if (!this._task_id) {\r\n      throw new Error(\r\n        \"This workflow is not enqueued and the execution status cannot be wait\"\r\n      );\r\n    }\r\n    const task_id = await this._task_id;\r\n    return new Promise<WorkflowOutput>((resolve, reject) => {\r\n      const zone = (fn: (done: () => void) => Function[]) => {\r\n        let offs: Function[] = [];\r\n        offs = fn(() => offs.forEach((cb) => cb()));\r\n      };\r\n      zone((done) => [\r\n        this.client.on(\"execution_interrupted\", (data) => {\r\n          if (data.prompt_id === task_id) {\r\n            reject(new Error(\"Execution Interrupted\"));\r\n            done();\r\n          }\r\n        }),\r\n        this.client.on(\"image_data\", (data) => {\r\n          if (this.executed) {\r\n            return;\r\n          }\r\n          this._result.images.push({\r\n            type: \"buff\",\r\n            data,\r\n          });\r\n        }),\r\n        this.client.on(\"executed\", (data) => {\r\n          if (data.prompt_id !== task_id) {\r\n            return;\r\n          }\r\n          this.load_result_data(data);\r\n          this.executed = true;\r\n          resolve(this._result);\r\n          done();\r\n        }),\r\n      ]);\r\n    });\r\n  }\r\n}\r\n","import { ComfyUIApiClient } from \"./ComfyUIApiClient\";\r\nimport { InvokedWorkflow } from \"./InvokedWorkflow\";\r\nimport { ComfyUINodeTypes } from \"./schema/comfyui.node.typs\";\r\nimport { WorkflowPromptNode } from \"./types\";\r\nimport { IWorkflow } from \"./types\";\r\n\r\nconst deepClone: <T>(obj: T) => T = globalThis.structuredClone\r\n  ? globalThis.structuredClone\r\n  : (x) => JSON.parse(JSON.stringify(x));\r\n\r\ntype NodeOutput = [string, number];\r\n\r\ntype NodeClassInputs = Record<\r\n  string,\r\n  string | boolean | number | null | undefined | NodeOutput\r\n>;\r\n\r\n// { k: { [k:string]: unknown } } => { k: any }\r\ntype InputsFormat<T> = {\r\n  [K in keyof T]: T[K] extends { [k: string]: unknown }\r\n    ? NodeOutput\r\n    : T[K] | NodeOutput;\r\n};\r\n\r\ninterface ComfyUINodeClass<INP extends NodeClassInputs = NodeClassInputs> {\r\n  (inputs: INP): NodeOutput[];\r\n}\r\n\r\ntype BuiltinNodeClasses = {\r\n  [K in keyof Required<ComfyUINodeTypes.NodeTypes>]: Required<\r\n    Required<ComfyUINodeTypes.NodeTypes>[K]\r\n  > extends {\r\n    inputs: infer INP;\r\n  }\r\n    ? ComfyUINodeClass<InputsFormat<INP> & NodeClassInputs>\r\n    : ComfyUINodeClass<NodeClassInputs>;\r\n};\r\n\r\n/**\r\n * A class for creating a workflow using a fluent API.\r\n * \r\n * @example\r\n * ```typescript\r\n  const workflow = new ComfyUIWorkflow();\r\n  const {\r\n    KSampler,\r\n    CheckpointLoaderSimple,\r\n    EmptyLatentImage,\r\n    CLIPTextEncode,\r\n    VAEDecode,\r\n    SaveImage,\r\n    NODE1,\r\n  } = workflow.classes;\r\n\r\n  const seed = Math.floor(Math.random() * 2 ** 32);\r\n  const pos = \"best quality, 1girl\";\r\n  const neg = \"worst quality, bad anatomy, embedding:NG_DeepNegative_V1_75T\";\r\n  const model1_name = \"lofi_v5.baked.fp16.safetensors\";\r\n  const model2_name = \"case-h-beta.baked.fp16.safetensors\";\r\n  const sampler_settings = {\r\n    seed,\r\n    steps: 35,\r\n    cfg: 4,\r\n    sampler_name: \"dpmpp_2m_sde_gpu\",\r\n    scheduler: \"karras\",\r\n    denoise: 1,\r\n  };\r\n\r\n  const [model1, clip1, vae1] = CheckpointLoaderSimple({\r\n    ckpt_name: model1_name,\r\n  });\r\n  const [model2, clip2, vae2] = CheckpointLoaderSimple({\r\n    ckpt_name: model2_name,\r\n  });\r\n\r\n  const dress_case = [\r\n    \"white yoga\",\r\n    \"black office\",\r\n    \"pink sportswear\",\r\n    \"cosplay\",\r\n  ];\r\n\r\n  const generate_pipeline = (model, clip, vae, pos, neg) => {\r\n    const [latent_image] = EmptyLatentImage({\r\n      width: 640,\r\n      height: 960,\r\n      batch_size: 1,\r\n    });\r\n    const [positive] = CLIPTextEncode({ text: pos, clip });\r\n    const [negative] = CLIPTextEncode({ text: neg, clip });\r\n    const [samples] = KSampler({\r\n      ...sampler_settings,\r\n      model,\r\n      positive,\r\n      negative,\r\n      latent_image,\r\n    });\r\n    const [image] = VAEDecode({ samples, vae });\r\n    return image;\r\n  };\r\n\r\n  for (const cloth of dress_case) {\r\n    const input_pos = `${pos}, ${cloth} dress`;\r\n    const image = generate_pipeline(model1, clip1, vae1, input_pos, neg);\r\n    SaveImage({\r\n      images: image,\r\n      filename_prefix: `${cloth}-lofi-v5`,\r\n    });\r\n\r\n    const input_pos2 = `${pos}, ${cloth} dress`;\r\n    const image2 = generate_pipeline(model2, clip2, vae2, input_pos2, neg);\r\n    SaveImage({\r\n      images: image2,\r\n      filename_prefix: `${cloth}-case-h-beta`,\r\n    });\r\n  }\r\n\r\n  return workflow;\r\n * ```\r\n */\r\nexport class ComfyUIWorkflow {\r\n  protected _workflow: IWorkflow = {\r\n    prompt: {},\r\n  };\r\n  protected _last_node_id = 0;\r\n\r\n  public classes = this._createClassesProxy();\r\n\r\n  protected _createClassesProxy() {\r\n    const source = {} as BuiltinNodeClasses & Record<string, ComfyUINodeClass>;\r\n    return new Proxy(source, {\r\n      get: (target, p, receiver) => {\r\n        if (p in target) {\r\n          return (target as any)[p];\r\n        }\r\n        return (inputs: Record<string, any>) => {\r\n          const node: WorkflowPromptNode = {\r\n            class_type: p.toString(),\r\n            inputs,\r\n          };\r\n          const id = (++this._last_node_id).toString();\r\n          this._workflow.prompt[id] = node;\r\n          return Array.from({ length: 10 }, (_, i) => {\r\n            return [id, i];\r\n          });\r\n        };\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Resets the workflow by clearing the prompt and setting the workflow to undefined.\r\n   */\r\n  public reset() {\r\n    this._workflow.prompt = {};\r\n    this._workflow.workflow = undefined;\r\n    this._last_node_id = 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the current workflow object.\r\n   *\r\n   * @return {IWorkflow} The current workflow object.\r\n   *\r\n   * @deprecated use `workflow` instead\r\n   */\r\n  public end() {\r\n    return this.workflow();\r\n  }\r\n\r\n  /**\r\n   * Returns the current workflow object.\r\n   *\r\n   * @return {IWorkflow} The current workflow object.\r\n   */\r\n  public workflow() {\r\n    return deepClone(this._workflow);\r\n  }\r\n\r\n  /**\r\n   * Invoke this workflow using the provided client.\r\n   *\r\n   * @param {ComfyUIApiClient} client - The client used to run the prompt.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves with the result of the prompt.\r\n   */\r\n  public invoke(client: ComfyUIApiClient) {\r\n    const invoked = this.instance(client);\r\n    invoked.enqueue();\r\n    const result = invoked.wait();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a new invoked workflow instance.\r\n   *\r\n   * @param {ComfyUIApiClient} client - The client used to run the prompt.\r\n   * @return {InvokedWorkflow} The invoked workflow instance.\r\n   */\r\n  public instance(client: ComfyUIApiClient) {\r\n    const { prompt, workflow } = this.workflow();\r\n    const invoked = new InvokedWorkflow({ prompt, workflow }, client);\r\n    return invoked;\r\n  }\r\n\r\n  /**\r\n   * Invokes the workflow using the provided client with polling.\r\n   *\r\n   * @param {ComfyUIApiClient} client - The client used to run the prompt.\r\n   * @return {Promise<WorkflowOutput>} A promise that resolves with the result of the prompt.\r\n   */\r\n  public invoke_polling(client: ComfyUIApiClient) {\r\n    const { prompt, workflow } = this.workflow();\r\n    return client.enqueue_polling(prompt, { workflow });\r\n  }\r\n}\r\n","import { ComfyUIApiClient } from \"./ComfyUIApiClient\";\r\n\r\ntype FnHook<\r\n  N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient,\r\n  Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N],\r\n> = Fn extends (...args: any) => any\r\n  ? {\r\n      type: \"function\";\r\n      name: N;\r\n      fn: (original: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>;\r\n    }\r\n  : never;\r\n\r\ntype PluginHook<\r\n  N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient,\r\n  Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N],\r\n> = FnHook<N, Fn>;\r\n\r\nexport class ClientPlugin {\r\n  private hooks = [] as PluginHook[];\r\n\r\n  public install(instance: ComfyUIApiClient) {\r\n    for (const hook of this.hooks) {\r\n      const ins = instance as any;\r\n      const original = ins[hook.name].bind(instance);\r\n      ins[hook.name] = (...args: Parameters<typeof original>) => {\r\n        return (hook.fn as any).bind(instance)(original, ...args);\r\n      };\r\n    }\r\n  }\r\n\r\n  protected addHook<\r\n    N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient,\r\n    Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N],\r\n  >(hook: PluginHook<N, Fn>) {\r\n    this.hooks.push(hook);\r\n  }\r\n}\r\n","import { ClientPlugin } from \"../ClientPlugin\";\r\n\r\n/**\r\n * Provide api-auth support for this https://github.com/liusida/ComfyUI-Login/tree/main extension\r\n */\r\nexport class LoginAuthPlugin extends ClientPlugin {\r\n  constructor(\r\n    readonly options: {\r\n      token: string;\r\n    }\r\n  ) {\r\n    super();\r\n\r\n    this.addHook({\r\n      type: \"function\",\r\n      name: \"apiURL\",\r\n      fn: (original, ...args) => {\r\n        const url = original(...args);\r\n        const urlObj = new URL(url);\r\n        urlObj.searchParams.set(\"token\", this.options.token);\r\n        return urlObj.toString();\r\n      },\r\n    });\r\n\r\n    this.addHook({\r\n      type: \"function\",\r\n      name: \"wsURL\",\r\n      fn: (original, ...args) => {\r\n        const url = original(...args);\r\n        const urlObj = new URL(url);\r\n        urlObj.searchParams.set(\"token\", this.options.token);\r\n        return urlObj.toString();\r\n      },\r\n    });\r\n  }\r\n}\r\n"],"names":["has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","event","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","concat","listeners","handlers","i","l","length","ee","Array","listenerCount","emit","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","module","exports","isNone","x","ComfyUIWsClient","loadImageData","buf","eventType","DataView","getUint32","Error","registered","constructor","config","_config$api_host","_config$api_base","_config$clientId","_config$WebSocket","_config$ssl","_config$user","_config$fetch","api_host","api_base","clientId","socket","WebSocket","ssl","user","fetch","socket_callbacks","_polling_timer","_polling_interval","closed","DEFAULT_API_HOST","DEFAULT_API_BASE","replace","c","r","Math","random","toString","globalThis","DEFAULT_USER","bind","console","warn","apiHeaders","options","_options$headers","_extends","Accept","headers","apiURL","route","url","URL","pathname","query","split","search","searchParams","set","viewURL","filename","subfolder","type","URLSearchParams","wsURL","fetchApi","addEventListener","callback","startPollingQueue","_this","setInterval","async","resp","status","json","error","addSocketCallback","removeEventListener","removeSocketCallbacks","createSocket","isReconnect","opened","binaryType","close","setTimeout","data","IS_BROWSER","Blob","ArrayBuffer","Buffer","isBuffer","isImageMessage","image","msg","JSON","parse","sid","includes","init","disconnect","connect","polling","enabled","websocket","_polling$interval","interval","_disconnectSocket","process","nextTick","_disconnectPolling","readyState","OPEN","clearInterval","window","GlobalCacheHub","_cached","KEY","Map","clear","get","key","value","CachedFn","ns","_options$expire_time","_options$enabled","expire_time_ms","cache_ns","expire_time","_defaultExpire","reset","_hashArgs","stringify","warp","now","Date","argsHash","cacheKey","hit_cached","expire","result","ComfyUIApiClient","super","_cached_fn","_plugins","cache","use","plugin","install","getExtensions","cached","getEmbeddings","_this2","getNodeDefs","_this3","resetCache","queuePrompt","queue_index","prompt","workflow","body","client_id","extra_data","extra_pnginfo","front","number","res","method","error_resp","text","response","getItems","getQueue","getHistory","Running","queue_running","map","remove","cb","interrupt","Pending","queue_pending","max_items","History","values","getSystemStats","postApi","deleteItem","id","delete","clearItems","free","params","getUserConfig","createUser","username","getSettings","getSetting","encodeURIComponent","storeSettings","settings","storeSetting","getUserData","file","storeUserData","getSamplers","_node$input","node","input","required","getSchedulers","_node$input2","getSDModels","_node$input3","getCNetModels","_node$input4","getUpscaleModels","_node$input5","getHyperNetworks","_node$input6","getLoRAs","_node$input7","getVAEs","_node$input8","getPromptStatus","prompt_id","running","some","task","_task$prompt","pending","_task$prompt2","done","getPromptOutputs","history","item","find","status_str","outputs","getPromptImageResult","images","flatMap","node_output","filter","Boolean","waitForPrompt","polling_ms","prompt_status","Promise","resolve","waitForPromptWebSocket","output","reject","offEvent2","offEvent","current_prompt_id","executed_output","randomizePrompt","class_type","inputs","seed","floor","_enqueue_prompt","disable_random_seed","runPrompt","enqueue_polling","enqueue","progress","_data","InvokedWorkflow","client","_task_id","_enqueue_req","_result","executed","wf","then","load_result_data","wait","task_id","offs","forEach","zone","deepClone","structuredClone","ComfyUIWorkflow","_workflow","_last_node_id","classes","_createClassesProxy","Proxy","target","p","receiver","from","_","end","invoke","invoked","instance","invoke_polling","ClientPlugin","hooks","hook","ins","original","addHook","LoginAuthPlugin","urlObj","token"],"mappings":"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"}