type CachedFnOptions = {
    expire_time?: number;
    enabled?: boolean;
};

interface IComfyApiConfig {
    /**
     * The host address of the API server, defaults to '127.0.0.1:8188'.
     * @type {string} [api_host="127.0.0.1:8188"]
     */
    api_host?: string;
    /**
     * The base path for the API endpoints, default is an empty string.
     * @type {string} [api_base=""]
     */
    api_base?: string;
    /**
     * The client identification string, default is an empty string.
     * @type {string} [clientId=""]
     */
    clientId?: string;
    /**
     * The name of the session, used for identifying the session instance, default is an empty string.
     * @type {string} [sessionName=""]
     */
    sessionName?: string;
    /**
     * The username for authentication, default is 'sc-comfy-ui-client'.
     * @type {string} [user="""]
     */
    user?: string;
    /**
     * Whether to use SSL for the connections, defaults to false.
     * @type {boolean} [ssl=false]
     */
    ssl?: boolean;
    /**
     * These settings are for compatibility with Node.js environments.
     * @type {typeof WebSocket} [WebSocket] - The WebSocket class to use.
     */
    WebSocket?: typeof WebSocket;
    /**
     * These settings are for compatibility with Node.js environments.
     * @type {typeof fetch} [fetch] - The fetch function to use.
     */
    fetch?: typeof fetch;
    cache?: CachedFnOptions;
}
type WorkflowOutput = {
    images: ({
        type: "buff";
        data: ArrayBuffer;
    } | {
        type: "url";
        data: string;
    })[];
    prompt_id: string;
};
interface IWorkflow {
    prompt: Record<string, WorkflowPromptNode>;
    workflow?: {
        nodes: [];
        links: [];
        groups: [];
        config: {};
        extra: {};
        version: 0.4;
    };
}
type WorkflowPromptNode = {
    class_type: string;
    inputs: Record<string, any>;
};

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 */
declare class EventEmitter<
  EventTypes extends EventEmitter.ValidEventTypes = string | symbol,
  Context extends any = any
> {
  static prefixed: string | boolean;

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   */
  eventNames(): Array<EventEmitter.EventNames<EventTypes>>;

  /**
   * Return the listeners registered for a given event.
   */
  listeners<T extends EventEmitter.EventNames<EventTypes>>(
    event: T
  ): Array<EventEmitter.EventListener<EventTypes, T>>;

  /**
   * Return the number of listeners listening to a given event.
   */
  listenerCount(event: EventEmitter.EventNames<EventTypes>): number;

  /**
   * Calls each of the listeners registered for a given event.
   */
  emit<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    ...args: EventEmitter.EventArgs<EventTypes, T>
  ): boolean;

  /**
   * Add a listener for a given event.
   */
  on<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;
  addListener<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;

  /**
   * Add a one-time listener for a given event.
   */
  once<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn: EventEmitter.EventListener<EventTypes, T>,
    context?: Context
  ): this;

  /**
   * Remove the listeners of a given event.
   */
  removeListener<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn?: EventEmitter.EventListener<EventTypes, T>,
    context?: Context,
    once?: boolean
  ): this;
  off<T extends EventEmitter.EventNames<EventTypes>>(
    event: T,
    fn?: EventEmitter.EventListener<EventTypes, T>,
    context?: Context,
    once?: boolean
  ): this;

  /**
   * Remove all listeners, or those of the specified event.
   */
  removeAllListeners(event?: EventEmitter.EventNames<EventTypes>): this;
}

declare namespace EventEmitter {
  export interface ListenerFn<Args extends any[] = any[]> {
    (...args: Args): void;
  }

  export interface EventEmitterStatic {
    new <
      EventTypes extends ValidEventTypes = string | symbol,
      Context = any
    >(): EventEmitter<EventTypes, Context>;
  }

  /**
   * `object` should be in either of the following forms:
   * ```
   * interface EventTypes {
   *   'event-with-parameters': any[]
   *   'event-with-example-handler': (...args: any[]) => void
   * }
   * ```
   */
  export type ValidEventTypes = string | symbol | object;

  export type EventNames<T extends ValidEventTypes> = T extends string | symbol
    ? T
    : keyof T;

  export type ArgumentMap<T extends object> = {
    [K in keyof T]: T[K] extends (...args: any[]) => void
      ? Parameters<T[K]>
      : T[K] extends any[]
      ? T[K]
      : any[];
  };

  export type EventListener<
    T extends ValidEventTypes,
    K extends EventNames<T>
  > = T extends string | symbol
    ? (...args: any[]) => void
    : (
        ...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]
      ) => void;

  export type EventArgs<
    T extends ValidEventTypes,
    K extends EventNames<T>
  > = Parameters<EventListener<T, K>>;

  export const EventEmitter: EventEmitterStatic;
}

declare namespace ComfyUiWsTypes {
    namespace Messages {
        interface Executed {
            node: string;
            output: Record<string, any>;
            prompt_id: string;
        }
        interface ExecutionInterrupted {
            prompt_id: string;
            node_id: string;
            node_type: string;
            executed: string[];
        }
        interface Executing {
            node: string;
            prompt_id: string;
        }
        interface Progress {
            value: number;
            max: number;
            prompt_id: string;
            last_prompt_id: string;
            node: string;
        }
        interface Status {
            status: {
                exec_info: {
                    queue_remaining: number;
                };
            };
        }
    }
}

type ComfyUIClientEvents = {
    status: [ComfyUiWsTypes.Messages.Status["status"] | null];
    progress: [ComfyUiWsTypes.Messages.Progress];
    executing: [ComfyUiWsTypes.Messages.Executing];
    executed: [ComfyUiWsTypes.Messages.Executed];
    execution_interrupted: [ComfyUiWsTypes.Messages.ExecutionInterrupted];
    execution_start: any;
    execution_error: any;
    execution_cached: any;
    reconnected: any;
    reconnecting: any;
    /**
     * load image data from websocket
     */
    image_data: [ArrayBuffer];
    /**
     * get all messages
     */
    message: any;
    /**
     * close client
     */
    close: any;
    /**
     * unhandled event message
     */
    unhandled: [{
        type: string;
        data: any;
    }];
};
/**
 * A client for interacting with the ComfyUI API server using WebSockets.
 *
 * NOTE: CORS policy: Request header field comfy-user is not allowed by Access-Control-Allow-Headers in preflight response. Please config.use empty string in browser.
 *
 * @example
 * ```typescript
 * const client = new ComfyUIWsClient({
 *  api_host: "YOUR_API_HOST"
 * });
 *
 * // Connect to the server
 * client.connect();
 *
 * // Listen for status updates
 * client.on("status", (status) => {
 *   console.log("Status:", status);
 * });
 *
 * // when done, close the client
 * client.close();
 */
declare class ComfyUIWsClient {
    static DEFAULT_API_HOST: string;
    static DEFAULT_API_BASE: string;
    static DEFAULT_USER: string;
    static IS_BROWSER: boolean;
    static loadImageData(buf: ArrayBuffer): ArrayBuffer;
    api_host: string;
    api_base: string;
    clientId?: string;
    socket?: WebSocket | null;
    WebSocket: typeof WebSocket;
    ssl: boolean;
    user: string;
    fetch: typeof fetch;
    events: EventEmitter<ComfyUIClientEvents & Record<string & {}, any>>;
    protected socket_callbacks: Record<string, any>;
    get registered(): ((string & {}) | keyof ComfyUIClientEvents)[];
    constructor(config: IComfyApiConfig);
    /**
     * Returns the headers for the API request.
     *
     * @param {RequestInit} [options] - (Optional) Additional options for the request.
     * @return {HeadersInit} The headers for the API request.
     */
    apiHeaders(options?: RequestInit): HeadersInit;
    /**
     * Generates the URL for the API endpoint based on the provided route.
     *
     * @param {string} route - The route for the API endpoint.
     * @return {string} The generated URL for the API endpoint.
     */
    apiURL(route: string): string;
    /**
     * Generates a URL for viewing a specific file with the given filename, subfolder, and type.
     *
     * @param {string} filename - The name of the file to view.
     * @param {string} subfolder - The subfolder where the file is located.
     * @param {string} type - The type of the file.
     * @return {string} The URL for viewing the file.
     */
    viewURL(filename: string, subfolder: string, type: string): string;
    /**
     * Generates the WebSocket URL based on the current API host and SSL configuration.
     *
     * @return {string} The generated WebSocket URL.
     */
    wsURL(): string;
    /**
     * Fetches API data based on the provided route and options.
     *
     * NOTE: CORS policy: Request header field comfy-user is not allowed by Access-Control-Allow-Headers in preflight response. Please use empty string in browser.
     *
     * @param {string} route - The route for the API request.
     * @param {RequestInit} [options] - (Optional) Additional options for the request.
     * @return {Promise<Response>} A promise that resolves to the API response.
     */
    fetchApi(route: string, options?: RequestInit): Promise<Response>;
    /**
     * Adds an event listener for the specified event type.
     *
     * @param {keyof ComfyUIClientEvents | (string & {})} type - The type of event to listen for.
     * @param {(...args: any) => void} callback - The callback function to be executed when the event is triggered.
     * @param {any} options - (Optional) Additional options for the event listener.
     * @return {() => void} A function that removes the event listener when called.
     */
    addEventListener<T extends EventEmitter.EventNames<ComfyUIClientEvents>>(type: T, callback: EventEmitter.EventListener<ComfyUIClientEvents, T>, options?: any): () => void;
    /**
     * Adds an event listener for the specified event type.
     *
     * @param {keyof ComfyUIClientEvents | (string & {})} type - The type of event to listen for.
     * @param {(...args: any) => void} callback - The callback function to be executed when the event is triggered.
     * @param {any} options - (Optional) Additional options for the event listener.
     * @return {() => void} A function that removes the event listener when called.
     */
    on<T extends EventEmitter.EventNames<ComfyUIClientEvents>>(type: T, callback: EventEmitter.EventListener<ComfyUIClientEvents, T>, options?: any): () => void;
    protected _polling_timer: any;
    protected _polling_interval: number;
    /**
     * Poll status for colab and other things that don't support websockets.
     */
    private startPollingQueue;
    protected addSocketCallback<K extends keyof WebSocketEventMap>(socket: WebSocket, type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, options?: boolean | AddEventListenerOptions): () => void;
    /**
     * Removes all event listeners from the given WebSocket and clears the socket_callbacks object.
     */
    protected removeSocketCallbacks(): void;
    /**
     * Creates and connects a WebSocket for realtime updates
     * @param {boolean} isReconnect If the socket is connection is a reconnect attempt
     */
    private createSocket;
    /**
     * Initializes sockets and realtime updates
     *
     * @deprecated move to client.connect()
     */
    init(): void;
    closed: boolean;
    /**
     * Closes the WebSocket connection and cleans up event listeners
     */
    close(): void;
    /**
     * Connects to the WebSocket server by creating a new socket connection.
     *
     * @param {Object} options - The options for connecting to the server.
     * @param {Object} options.polling - The options for polling.
     * @param {boolean} options.polling.enabled - Whether polling is enabled.
     * @param {number} [options.polling.interval] - The interval for polling.
     * @param {Object} options.websocket - The options for the WebSocket connection.
     * @param {boolean} options.websocket.enabled - Whether the WebSocket connection is enabled.
     * @return {this} - The instance of the class.
     */
    connect({ polling, websocket, }?: {
        polling?: {
            enabled: boolean;
            interval?: number;
        };
        websocket?: {
            enabled: boolean;
        };
    }): this;
    /**
     * Disconnects the WebSocket connection and cleans up event listeners.
     */
    disconnect(): void;
    /**
     * Disconnects the WebSocket connection and cleans up event listeners.
     *
     * @return {void} This function does not return anything.
     */
    _disconnectSocket(): void;
    /**
     * Disconnects the polling timer and sets it to null.
     *
     * @return {void}
     */
    _disconnectPolling(): void;
}

type FnHook<N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient, Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N]> = Fn extends (...args: any) => any ? {
    type: "function";
    name: N;
    fn: (original: Fn, ...args: Parameters<Fn>) => ReturnType<Fn>;
} : never;
type PluginHook<N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient, Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N]> = FnHook<N, Fn>;
declare class ClientPlugin {
    private hooks;
    install(instance: ComfyUIApiClient): void;
    protected addHook<N extends keyof ComfyUIApiClient = keyof ComfyUIApiClient, Fn extends ComfyUIApiClient[N] = ComfyUIApiClient[N]>(hook: PluginHook<N, Fn>): void;
}

declare namespace ComfyUIClientResponseTypes {
    export interface SystemStatsRoot {
        system: System;
        devices: Device[];
    }
    export interface System {
        os: string;
        python_version: string;
        embedded_python: boolean;
    }
    export interface Device {
        name: string;
        type: string;
        index: number;
        vram_total: number;
        vram_free: number;
        torch_vram_total: number;
        torch_vram_free: number;
    }
    interface NodeConfig {
        input: NodeInputs;
        output: Array<string[] | string>;
        output_is_list: boolean[];
        output_name: string[];
        name: string;
        display_name: string;
        description: string;
        category: string;
        output_node: boolean;
    }
    type NodeInputs = {
        required?: Record<string, NodeSlot>;
        optional?: Record<string, NodeSlot>;
        hidden?: Record<string, NodeSlot>;
    };
    type NodeSlot = [string, NodeOptions] | [string];
    type NodeOptions = Record<string, any>;
    export interface ObjectInfo {
        [k: string]: NodeConfig;
    }
    export type QueuePrompt = {
        prompt_id: string;
        number: number;
        node_errors: any;
    } | {
        error: string;
        node_errors: Record<string, {
            class_type: string;
            dependent_outputs: string[];
            errors: Array<{
                details: string;
                extra_info: any;
                message: string;
                type: string;
            }>;
        }>;
    };
    export {  };
}

/**
 * The ComfyUIApiClient class provides a high-level interface for interacting with the ComfyUI API.
 *
 * @extends ComfyUIWsClient
 *
 * @example
 * ```typescript
 * const client = new ComfyUIApiClient({
 *  api_host: "YOUR_API_HOST",
 *  clientId: "YOUR_CLIENT_ID",
 * });
 *
 * const extensions = await client.getEmbeddings();
 * console.log(extensions);
 * ```
 */
declare class ComfyUIApiClient extends ComfyUIWsClient {
    private _cached_fn;
    private _plugins;
    constructor(config: IComfyApiConfig);
    /**
     * Use a plugin by calling its install method on this instance.
     *
     * @param {ClientPlugin} plugin - The plugin to install.
     */
    use(plugin: ClientPlugin): void;
    /**
     * Gets a list of extension urls
     * @returns An array of script urls to import
     */
    getExtensions(): Promise<string[]>;
    /**
     * Gets a list of embedding names
     * @returns An array of script urls to import
     */
    getEmbeddings(): Promise<string[]>;
    /**
     * Loads node object definitions for the graph
     * @returns {Promise<ComfyUIClientResponseTypes.ObjectInfo>} The object info for the graph
     */
    getNodeDefs(): Promise<ComfyUIClientResponseTypes.ObjectInfo>;
    /**
     * Clears the node object definitions cache
     */
    resetCache(): void;
    /**
     *
     * @param {number} queue_index The index at which to queue the prompt, passing -1 will insert the prompt at the front of the queue
     * @param {Object} options
     * @param {Object} options.prompt The prompt to queue
     * @param {Object} options.workflow This png info to be added to resulting image
     * @returns {Promise<ComfyUIClientResponseTypes.QueuePrompt>} The response from the server
     */
    queuePrompt(queue_index: number, { prompt, workflow }: {
        prompt: any;
        workflow: any;
    }): Promise<ComfyUIClientResponseTypes.QueuePrompt>;
    /**
     * Loads a list of items (queue or history)
     * @param {"queue" | "history"} type The type of items to load, queue or history
     * @returns The items of the specified type grouped by their status
     */
    getItems(type: "history"): ReturnType<ComfyUIApiClient["getHistory"]>;
    getItems(type: "queue"): ReturnType<ComfyUIApiClient["getQueue"]>;
    /**
     * Gets the current state of the queue
     * @returns The currently running and queued items
     */
    getQueue(): Promise<{
        Running: Array<Record<string, unknown>>;
        Pending: Array<Record<string, unknown>>;
    }>;
    /**
     * Gets the prompt execution history
     * @returns Prompt history including node outputs
     */
    getHistory(max_items?: number): Promise<{
        History: Array<{
            prompt: [number, string, any, any, any];
            outputs: Record<string, unknown>;
            status: {
                status_str: string;
                completed: boolean;
                messages: any[];
            };
        }>;
    }>;
    /**
     * Gets system & device stats
     * @returns {ComfyUIClientResponseTypes.SystemStatsRoot} System stats such as python version, OS, per device info
     */
    getSystemStats(): Promise<ComfyUIClientResponseTypes.SystemStatsRoot>;
    /**
     * Sends a POST request to the API
     * @param {"queue" | "history"} type The endpoint to post to
     * @param {any} body Optional POST data
     */
    private postApi;
    /**
     * Deletes an item from the specified list
     * @param {"queue" | "history"} type The type of item to delete, queue or history
     * @param {any} id The id of the item to delete
     */
    deleteItem(type: "queue" | "history", id: any): Promise<void>;
    /**
     * Clears the specified list
     * @param {"queue" | "history"} type The type of list to clear, queue or history
     */
    clearItems(type: "queue" | "history"): Promise<void>;
    /**
     * Interrupts the execution of the running prompt
     */
    interrupt(): Promise<void>;
    /**
     * Free up memory by unloading models and freeing memory
     */
    free(params?: {
        unload_models?: boolean;
        free_memory?: boolean;
    }): Promise<void>;
    /**
     * Gets user configuration data and where data should be stored
     * @returns { Promise<{ storage: "server" | "browser", users?: Promise<string, unknown>, migrated?: boolean }> }
     */
    getUserConfig(): Promise<any>;
    /**
     * Creates a new user
     * @param { string } username
     * @returns The fetch response
     */
    createUser(username: string): Promise<Response>;
    /**
     * Gets all setting values for the current user
     * @returns { Promise<string, unknown> } A dictionary of id -> value
     */
    getSettings(): Promise<Record<string, unknown>>;
    /**
     * Gets a setting for the current user
     * @param { string } id The id of the setting to fetch
     * @returns { Promise<unknown> } The setting value
     */
    getSetting(id: string): Promise<unknown>;
    /**
     * Stores a dictionary of settings for the current user
     * @param { Record<string, unknown> } settings Dictionary of setting id -> value to save
     * @returns { Promise<void> }
     */
    storeSettings(settings: Record<string, unknown>): Promise<Response>;
    /**
     * Stores a setting for the current user
     * @param { string } id The id of the setting to update
     * @param { unknown } value The value of the setting
     * @returns { Promise<void> }
     */
    storeSetting(id: string, value: unknown): Promise<Response>;
    /**
     * Gets a user data file for the current user
     * @param { string } file The name of the userdata file to load
     * @param { RequestInit } [options]
     * @returns { Promise<unknown> } The fetch response object
     */
    getUserData(file: string, options?: RequestInit): Promise<Response>;
    /**
     * Stores a user data file for the current user
     * @param { string } file The name of the userdata file to save
     * @param { any } data The data to save to the file
     * @param { RequestInit & { stringify?: boolean, throwOnError?: boolean } } [options]
     * @returns { Promise<void> }
     */
    storeUserData(file: string, data: any, options?: RequestInit & {
        stringify?: boolean;
        throwOnError?: boolean;
    }): Promise<void>;
    /**
     * Retrieves the list of samplers from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the sampler names.
     */
    getSamplers(): Promise<string[]>;
    /**
     * Retrieves the list of schedulers from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the scheduler names.
     */
    getSchedulers(): Promise<string[]>;
    /**
     * Retrieves the list of model names from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.
     */
    getSDModels(): Promise<string[]>;
    /**
     * Retrieves the list of model names from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.
     */
    getCNetModels(): Promise<string[]>;
    /**
     * Retrieves the list of model names from the node definitions for the UpscaleModelLoader node.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the model names.
     */
    getUpscaleModels(): Promise<string[]>;
    /**
     * Retrieves the list of hypernetwork names from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the hypernetwork names.
     */
    getHyperNetworks(): Promise<string[]>;
    /**
     * Retrieves the list of LoRAs from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the LoRAs.
     */
    getLoRAs(): Promise<string[]>;
    /**
     * Retrieves the list of VAE names from the node definitions.
     *
     * @return {Promise<string[]>} A promise that resolves to an array of strings representing the VAE names.
     */
    getVAEs(): Promise<string[]>;
    /**
     * Retrieves the status of a prompt based on the provided prompt ID.
     *
     * @param {string} prompt_id - The ID of the prompt to check status for.
     * @return {Object} Object containing the running, pending, and done status of the prompt.
     */
    getPromptStatus(prompt_id: string): Promise<{
        running: boolean;
        pending: boolean;
        done: boolean;
    }>;
    /**
     * Retrieves the outputs of a prompt with the given ID from the history.
     *
     * @param {string} prompt_id - The ID of the prompt to retrieve the outputs for.
     * @return {Promise<any>} A promise that resolves to the outputs of the prompt.
     * @throws {Error} If the prompt with the given ID is not found in the history or if it failed with a non-"success" status.
     */
    getPromptOutputs(prompt_id: string): Promise<Record<string, unknown>>;
    /**
     * Retrieves the result of a prompt based on the provided prompt ID.
     *
     * @param {string} prompt_id - The ID of the prompt to retrieve the result for.
     * @return {WorkflowOutput} An object containing the images associated with the prompt and the prompt ID.
     */
    getPromptImageResult(prompt_id: string): Promise<WorkflowOutput>;
    /**
     * Asynchronously waits for the prompt with the provided ID to be done.
     *
     * @param {string} prompt_id - The ID of the prompt to wait for.
     * @param {number} [polling_ms=1000] - The number of milliseconds to wait between checks.
     * @return {void}
     */
    waitForPrompt(prompt_id: string, polling_ms?: number): Promise<void>;
    /**
     * Asynchronously waits for the prompt with the provided ID to be done using WebSocket.
     *
     * @param {string} prompt_id - The ID of the prompt to wait for.
     * @return {Promise<WorkflowOutput>} A promise that resolves to a WorkflowOutput object containing the images and prompt_id.
     */
    waitForPromptWebSocket(prompt_id: string): Promise<WorkflowOutput>;
    /**
     * Randomizes the seed value of nodes with class type "KSampler" in the prompt.
     *
     * @param {Record<string, unknown>} prompt - The prompt object to randomize.
     * @return {void}
     */
    randomizePrompt(prompt: Record<string, unknown>): void;
    /**
     * Asynchronously enqueues a prompt with optional workflow and random seed.
     *
     * @param {Record<string, unknown>} prompt - The prompt to enqueue.
     * @param {Object} [options] - The options for enqueueing the prompt.
     * @param {Record<string, unknown>} [options.workflow] - The workflow for the prompt.
     * @param {boolean} [options.disable_random_seed=false] - Whether to disable random seed.
     * @return {Promise<{ prompt_id: string; number: number; node_errors: any; }>} A promise that resolves with the enqueued prompt response.
     * @throws {Error} If there is an error in the response.
     */
    _enqueue_prompt(prompt: Record<string, unknown>, options?: {
        workflow?: Record<string, unknown>;
        disable_random_seed?: boolean;
    }): Promise<{
        prompt_id: string;
        number: number;
        node_errors: any;
    }>;
    /**
     * Asynchronously runs a prompt with the provided options.
     *
     * This function does not use WebSocket, but uses polling to get the result
     * So if your workflow contains custom ws events, this function will not be able to get these events
     *
     * @param {Record<string, unknown>} prompt - The prompt to run.
     * @param {Object} options - The options for running the prompt.
     * @param {Record<string, unknown>} options.workflow - The workflow for the prompt, It will be added to the png info of the generated image.
     * @param {boolean} [options.disable_random_seed] - Flag to disable random seed generation.
     * @param {number} [options.polling_ms=1000] - The number of milliseconds to polling query prompt result.
     * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.
     *
     * @deprecated Use `enqueue_polling` instead
     */
    runPrompt(prompt: Record<string, unknown>, options?: {
        workflow?: Record<string, unknown>;
        disable_random_seed?: boolean;
        polling_ms?: number;
    }): Promise<WorkflowOutput>;
    /**
     * Asynchronously runs a prompt with the provided options.
     *
     * This function does not use WebSocket, but uses polling to get the result
     * So if your workflow contains custom ws events, this function will not be able to get these events
     *
     * @param {Record<string, unknown>} prompt - The prompt to run.
     * @param {Object} options - The options for running the prompt.
     * @param {Record<string, unknown>} options.workflow - The workflow for the prompt, It will be added to the png info of the generated image.
     * @param {boolean} [options.disable_random_seed] - Flag to disable random seed generation.
     * @param {number} [options.polling_ms=1000] - The number of milliseconds to polling query prompt result.
     * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.
     */
    enqueue_polling(prompt: Record<string, unknown>, options?: {
        workflow?: Record<string, unknown>;
        disable_random_seed?: boolean;
        polling_ms?: number;
    }): Promise<WorkflowOutput>;
    /**
     * Enqueues a prompt and waits for the corresponding prompt websocket.
     *
     * @param {Record<string, unknown>} prompt - The prompt to enqueue.
     * @param {{ workflow?: Record<string, unknown>; disable_random_seed?: boolean; }} [options] - The options for enqueueing the prompt.
     * @param {Record<string, unknown>} [options.workflow] - This data for PNG info.
     * @param {boolean} [options.disable_random_seed] - Whether to disable random seed.
     * @return {Promise<WorkflowOutput>} A promise that resolves with the prompt result.
     */
    enqueue(prompt: Record<string, unknown>, options?: {
        /**
         * this data for PNG info
         */
        workflow?: Record<string, unknown>;
        disable_random_seed?: boolean;
        progress?: (p: ComfyUiWsTypes.Messages.Progress) => void;
    }): Promise<WorkflowOutput>;
}

declare class InvokedWorkflow {
    workflow: IWorkflow;
    client: ComfyUIApiClient;
    protected _task_id?: Promise<string>;
    protected _enqueue_req?: ReturnType<ComfyUIApiClient["_enqueue_prompt"]>;
    protected _result: WorkflowOutput;
    executed: boolean;
    constructor(workflow: IWorkflow, client: ComfyUIApiClient);
    enqueue(): void;
    protected load_result_data(data: any): void;
    query(): Promise<{
        running: boolean;
        pending: boolean;
        done: boolean;
    }>;
    interrupt(): Promise<void>;
    wait(): Promise<WorkflowOutput>;
}

declare namespace ComfyUINodeTypes {
    interface NodeTypes {
        CLIPLoader?: CLIPLoader;
        CLIPSetLastLayer?: CLIPSetLastLayer;
        CLIPTextEncode?: CLIPTextEncode;
        CLIPVisionEncode?: CLIPVisionEncode;
        CLIPVisionLoader?: CLIPVisionLoader;
        CheckpointLoader?: CheckpointLoader;
        CheckpointLoaderSimple?: CheckpointLoaderSimple;
        ConditioningAverage?: ConditioningAverage;
        ConditioningCombine?: ConditioningCombine;
        ConditioningConcat?: ConditioningConcat;
        ConditioningSetArea?: ConditioningSetArea;
        ConditioningSetAreaPercentage?: ConditioningSetAreaPercentage;
        ConditioningSetAreaStrength?: ConditioningSetAreaStrength;
        ConditioningSetMask?: ConditioningSetMask;
        ConditioningSetTimestepRange?: ConditioningSetTimestepRange;
        ConditioningZeroOut?: ConditioningZeroOut;
        ControlNetApply?: ControlNetApply;
        ControlNetApplyAdvanced?: ControlNetApplyAdvanced;
        ControlNetLoader?: ControlNetLoader;
        DiffControlNetLoader?: DiffControlNetLoader;
        DiffusersLoader?: DiffusersLoader;
        DualCLIPLoader?: DualCLIPLoader;
        EmptyImage?: EmptyImage;
        EmptyLatentImage?: EmptyLatentImage;
        GLIGENLoader?: GLIGENLoader;
        GLIGENTextBoxApply?: GLIGENTextBoxApply;
        ImageBatch?: ImageBatch;
        ImageInvert?: ImageInvert;
        ImagePadForOutpaint?: ImagePadForOutpaint;
        ImageScale?: ImageScale;
        ImageScaleBy?: ImageScaleBy;
        InpaintModelConditioning?: InpaintModelConditioning;
        KSampler?: KSampler;
        KSamplerAdvanced?: KSamplerAdvanced;
        LatentBlend?: LatentBlend;
        LatentComposite?: LatentComposite;
        LatentCrop?: LatentCrop;
        LatentFlip?: LatentFlip;
        LatentFromBatch?: LatentFromBatch;
        LatentRotate?: LatentRotate;
        LatentUpscale?: LatentUpscale;
        LatentUpscaleBy?: LatentUpscaleBy;
        LoadImage?: LoadImage;
        LoadImageMask?: LoadImageMask;
        LoadLatent?: LoadLatent;
        LoraLoader?: LoraLoader;
        LoraLoaderModelOnly?: LoraLoaderModelOnly;
        PreviewImage?: PreviewImage;
        RepeatLatentBatch?: RepeatLatentBatch;
        SaveImage?: SaveImage;
        SaveLatent?: SaveLatent;
        SetLatentNoiseMask?: SetLatentNoiseMask;
        StyleModelApply?: StyleModelApply;
        StyleModelLoader?: StyleModelLoader;
        UNETLoader?: UNETLoader;
        VAEDecode?: VAEDecode;
        VAEDecodeTiled?: VAEDecodeTiled;
        VAEEncode?: VAEEncode;
        VAEEncodeForInpaint?: VAEEncodeForInpaint;
        VAEEncodeTiled?: VAEEncodeTiled;
        VAELoader?: VAELoader;
        unCLIPCheckpointLoader?: UnCLIPCheckpointLoader;
        unCLIPConditioning?: UnCLIPConditioning;
    }
    interface CLIPLoader {
        /**
         * INPUT_TYPES: clip_name
         */
        inputs?: {
            clip_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CLIP
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CLIPSetLastLayer {
        /**
         * INPUT_TYPES: clip, stop_at_clip_layer
         */
        inputs?: {
            clip: {
                [k: string]: unknown;
            };
            stop_at_clip_layer: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CLIP
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CLIPTextEncode {
        /**
         * INPUT_TYPES: text, clip
         */
        inputs?: {
            text: string;
            clip: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CLIPVisionEncode {
        /**
         * INPUT_TYPES: clip_vision, image
         */
        inputs?: {
            clip_vision: {
                [k: string]: unknown;
            };
            image: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CLIP_VISION_OUTPUT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CLIPVisionLoader {
        /**
         * INPUT_TYPES: clip_name
         */
        inputs?: {
            clip_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CLIP_VISION
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CheckpointLoader {
        /**
         * INPUT_TYPES: config_name, ckpt_name
         */
        inputs?: {
            config_name: string;
            ckpt_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL, CLIP, VAE
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface CheckpointLoaderSimple {
        /**
         * INPUT_TYPES: ckpt_name
         */
        inputs?: {
            ckpt_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL, CLIP, VAE
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningAverage {
        /**
         * INPUT_TYPES: conditioning_to, conditioning_from, conditioning_to_strength
         */
        inputs?: {
            conditioning_to: {
                [k: string]: unknown;
            };
            conditioning_from: {
                [k: string]: unknown;
            };
            conditioning_to_strength: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningCombine {
        /**
         * INPUT_TYPES: conditioning_1, conditioning_2
         */
        inputs?: {
            conditioning_1: {
                [k: string]: unknown;
            };
            conditioning_2: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningConcat {
        /**
         * INPUT_TYPES: conditioning_to, conditioning_from
         */
        inputs?: {
            conditioning_to: {
                [k: string]: unknown;
            };
            conditioning_from: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningSetArea {
        /**
         * INPUT_TYPES: conditioning, width, height, x, y, strength
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            width: number;
            height: number;
            x: number;
            y: number;
            strength: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningSetAreaPercentage {
        /**
         * INPUT_TYPES: conditioning, width, height, x, y, strength
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            width: number;
            height: number;
            x: number;
            y: number;
            strength: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningSetAreaStrength {
        /**
         * INPUT_TYPES: conditioning, strength
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            strength: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningSetMask {
        /**
         * INPUT_TYPES: conditioning, mask, strength, set_cond_area
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            mask: {
                [k: string]: unknown;
            };
            strength: number;
            set_cond_area: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningSetTimestepRange {
        /**
         * INPUT_TYPES: conditioning, start, end
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            start: number;
            end: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ConditioningZeroOut {
        /**
         * INPUT_TYPES: conditioning
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ControlNetApply {
        /**
         * INPUT_TYPES: conditioning, control_net, image, strength
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            control_net: {
                [k: string]: unknown;
            };
            image: {
                [k: string]: unknown;
            };
            strength: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ControlNetApplyAdvanced {
        /**
         * INPUT_TYPES: positive, negative, control_net, image, strength, start_percent, end_percent
         */
        inputs?: {
            positive: {
                [k: string]: unknown;
            };
            negative: {
                [k: string]: unknown;
            };
            control_net: {
                [k: string]: unknown;
            };
            image: {
                [k: string]: unknown;
            };
            strength: number;
            start_percent: number;
            end_percent: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING, CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ControlNetLoader {
        /**
         * INPUT_TYPES: control_net_name
         */
        inputs?: {
            control_net_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONTROL_NET
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface DiffControlNetLoader {
        /**
         * INPUT_TYPES: model, control_net_name
         */
        inputs?: {
            model: {
                [k: string]: unknown;
            };
            control_net_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONTROL_NET
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface DiffusersLoader {
        /**
         * INPUT_TYPES: model_path
         */
        inputs?: {
            model_path: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL, CLIP, VAE
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface DualCLIPLoader {
        /**
         * INPUT_TYPES: clip_name1, clip_name2
         */
        inputs?: {
            clip_name1: string;
            clip_name2: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CLIP
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface EmptyImage {
        /**
         * INPUT_TYPES: width, height, batch_size, color
         */
        inputs?: {
            width: number;
            height: number;
            batch_size: number;
            color: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface EmptyLatentImage {
        /**
         * INPUT_TYPES: width, height, batch_size
         */
        inputs?: {
            width: number;
            height: number;
            batch_size: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface GLIGENLoader {
        /**
         * INPUT_TYPES: gligen_name
         */
        inputs?: {
            gligen_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: GLIGEN
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface GLIGENTextBoxApply {
        /**
         * INPUT_TYPES: conditioning_to, clip, gligen_textbox_model, text, width, height, x, y
         */
        inputs?: {
            conditioning_to: {
                [k: string]: unknown;
            };
            clip: {
                [k: string]: unknown;
            };
            gligen_textbox_model: {
                [k: string]: unknown;
            };
            text: string;
            width: number;
            height: number;
            x: number;
            y: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ImageBatch {
        /**
         * INPUT_TYPES: image1, image2
         */
        inputs?: {
            image1: {
                [k: string]: unknown;
            };
            image2: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ImageInvert {
        /**
         * INPUT_TYPES: image
         */
        inputs?: {
            image: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ImagePadForOutpaint {
        /**
         * INPUT_TYPES: image, left, top, right, bottom, feathering
         */
        inputs?: {
            image: {
                [k: string]: unknown;
            };
            left: number;
            top: number;
            right: number;
            bottom: number;
            feathering: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE, MASK
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ImageScale {
        /**
         * INPUT_TYPES: image, upscale_method, width, height, crop
         */
        inputs?: {
            image: {
                [k: string]: unknown;
            };
            upscale_method: string;
            width: number;
            height: number;
            crop: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface ImageScaleBy {
        /**
         * INPUT_TYPES: image, upscale_method, scale_by
         */
        inputs?: {
            image: {
                [k: string]: unknown;
            };
            upscale_method: string;
            scale_by: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface InpaintModelConditioning {
        /**
         * INPUT_TYPES: positive, negative, vae, pixels, mask
         */
        inputs?: {
            positive: {
                [k: string]: unknown;
            };
            negative: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            pixels: {
                [k: string]: unknown;
            };
            mask: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING, CONDITIONING, LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface KSampler {
        /**
         * INPUT_TYPES: model, seed, steps, cfg, sampler_name, scheduler, positive, negative, latent_image, denoise
         */
        inputs?: {
            model: {
                [k: string]: unknown;
            };
            seed: number;
            steps: number;
            cfg: number;
            sampler_name: string;
            scheduler: string;
            positive: {
                [k: string]: unknown;
            };
            negative: {
                [k: string]: unknown;
            };
            latent_image: {
                [k: string]: unknown;
            };
            denoise: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface KSamplerAdvanced {
        /**
         * INPUT_TYPES: model, add_noise, noise_seed, steps, cfg, sampler_name, scheduler, positive, negative, latent_image, start_at_step, end_at_step, return_with_leftover_noise
         */
        inputs?: {
            model: {
                [k: string]: unknown;
            };
            add_noise: string;
            noise_seed: number;
            steps: number;
            cfg: number;
            sampler_name: string;
            scheduler: string;
            positive: {
                [k: string]: unknown;
            };
            negative: {
                [k: string]: unknown;
            };
            latent_image: {
                [k: string]: unknown;
            };
            start_at_step: number;
            end_at_step: number;
            return_with_leftover_noise: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentBlend {
        /**
         * INPUT_TYPES: samples1, samples2, blend_factor
         */
        inputs?: {
            samples1: {
                [k: string]: unknown;
            };
            samples2: {
                [k: string]: unknown;
            };
            blend_factor: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentComposite {
        /**
         * INPUT_TYPES: samples_to, samples_from, x, y, feather
         */
        inputs?: {
            samples_to: {
                [k: string]: unknown;
            };
            samples_from: {
                [k: string]: unknown;
            };
            x: number;
            y: number;
            feather: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentCrop {
        /**
         * INPUT_TYPES: samples, width, height, x, y
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            width: number;
            height: number;
            x: number;
            y: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentFlip {
        /**
         * INPUT_TYPES: samples, flip_method
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            flip_method: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentFromBatch {
        /**
         * INPUT_TYPES: samples, batch_index, length
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            batch_index: number;
            length: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentRotate {
        /**
         * INPUT_TYPES: samples, rotation
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            rotation: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentUpscale {
        /**
         * INPUT_TYPES: samples, upscale_method, width, height, crop
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            upscale_method: string;
            width: number;
            height: number;
            crop: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LatentUpscaleBy {
        /**
         * INPUT_TYPES: samples, upscale_method, scale_by
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            upscale_method: string;
            scale_by: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LoadImage {
        /**
         * INPUT_TYPES: image
         */
        inputs?: {
            image: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE, MASK
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LoadImageMask {
        /**
         * INPUT_TYPES: image, channel
         */
        inputs?: {
            image: string;
            channel: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MASK
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LoadLatent {
        /**
         * INPUT_TYPES: latent
         */
        inputs?: {
            latent: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LoraLoader {
        /**
         * INPUT_TYPES: model, clip, lora_name, strength_model, strength_clip
         */
        inputs?: {
            model: {
                [k: string]: unknown;
            };
            clip: {
                [k: string]: unknown;
            };
            lora_name: string;
            strength_model: number;
            strength_clip: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL, CLIP
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface LoraLoaderModelOnly {
        /**
         * INPUT_TYPES: model, lora_name, strength_model
         */
        inputs?: {
            model: {
                [k: string]: unknown;
            };
            lora_name: string;
            strength_model: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface PreviewImage {
        /**
         * INPUT_TYPES: images
         */
        inputs?: {
            images: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        [k: string]: unknown;
    }
    interface RepeatLatentBatch {
        /**
         * INPUT_TYPES: samples, amount
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            amount: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface SaveImage {
        /**
         * INPUT_TYPES: images, filename_prefix
         */
        inputs?: {
            images: {
                [k: string]: unknown;
            };
            filename_prefix: string;
            [k: string]: unknown;
        };
        [k: string]: unknown;
    }
    interface SaveLatent {
        /**
         * INPUT_TYPES: samples, filename_prefix
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            filename_prefix: string;
            [k: string]: unknown;
        };
        [k: string]: unknown;
    }
    interface SetLatentNoiseMask {
        /**
         * INPUT_TYPES: samples, mask
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            mask: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface StyleModelApply {
        /**
         * INPUT_TYPES: conditioning, style_model, clip_vision_output
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            style_model: {
                [k: string]: unknown;
            };
            clip_vision_output: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface StyleModelLoader {
        /**
         * INPUT_TYPES: style_model_name
         */
        inputs?: {
            style_model_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: STYLE_MODEL
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface UNETLoader {
        /**
         * INPUT_TYPES: unet_name
         */
        inputs?: {
            unet_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAEDecode {
        /**
         * INPUT_TYPES: samples, vae
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAEDecodeTiled {
        /**
         * INPUT_TYPES: samples, vae, tile_size
         */
        inputs?: {
            samples: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            tile_size: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: IMAGE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAEEncode {
        /**
         * INPUT_TYPES: pixels, vae
         */
        inputs?: {
            pixels: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAEEncodeForInpaint {
        /**
         * INPUT_TYPES: pixels, vae, mask, grow_mask_by
         */
        inputs?: {
            pixels: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            mask: {
                [k: string]: unknown;
            };
            grow_mask_by: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAEEncodeTiled {
        /**
         * INPUT_TYPES: pixels, vae, tile_size
         */
        inputs?: {
            pixels: {
                [k: string]: unknown;
            };
            vae: {
                [k: string]: unknown;
            };
            tile_size: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: LATENT
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface VAELoader {
        /**
         * INPUT_TYPES: vae_name
         */
        inputs?: {
            vae_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: VAE
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface UnCLIPCheckpointLoader {
        /**
         * INPUT_TYPES: ckpt_name
         */
        inputs?: {
            ckpt_name: string;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: MODEL, CLIP, VAE, CLIP_VISION
         */
        outputs?: [
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            },
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
    interface UnCLIPConditioning {
        /**
         * INPUT_TYPES: conditioning, clip_vision_output, strength, noise_augmentation
         */
        inputs?: {
            conditioning: {
                [k: string]: unknown;
            };
            clip_vision_output: {
                [k: string]: unknown;
            };
            strength: number;
            noise_augmentation: number;
            [k: string]: unknown;
        };
        /**
         * RETURN_TYPES: CONDITIONING
         */
        outputs?: [
            {
                [k: string]: unknown;
            }
        ];
        [k: string]: unknown;
    }
}

type NodeOutput = [string, number];
type NodeClassInputs = Record<string, string | boolean | number | null | undefined | NodeOutput>;
type InputsFormat<T> = {
    [K in keyof T]: T[K] extends {
        [k: string]: unknown;
    } ? NodeOutput : T[K] | NodeOutput;
};
interface ComfyUINodeClass<INP extends NodeClassInputs = NodeClassInputs> {
    (inputs: INP): NodeOutput[];
}
type BuiltinNodeClasses = {
    [K in keyof Required<ComfyUINodeTypes.NodeTypes>]: Required<Required<ComfyUINodeTypes.NodeTypes>[K]> extends {
        inputs: infer INP;
    } ? ComfyUINodeClass<InputsFormat<INP> & NodeClassInputs> : ComfyUINodeClass<NodeClassInputs>;
};
/**
 * A class for creating a workflow using a fluent API.
 *
 * @example
 * ```typescript
  const workflow = new ComfyUIWorkflow();
  const {
    KSampler,
    CheckpointLoaderSimple,
    EmptyLatentImage,
    CLIPTextEncode,
    VAEDecode,
    SaveImage,
    NODE1,
  } = workflow.classes;

  const seed = Math.floor(Math.random() * 2 ** 32);
  const pos = "best quality, 1girl";
  const neg = "worst quality, bad anatomy, embedding:NG_DeepNegative_V1_75T";
  const model1_name = "lofi_v5.baked.fp16.safetensors";
  const model2_name = "case-h-beta.baked.fp16.safetensors";
  const sampler_settings = {
    seed,
    steps: 35,
    cfg: 4,
    sampler_name: "dpmpp_2m_sde_gpu",
    scheduler: "karras",
    denoise: 1,
  };

  const [model1, clip1, vae1] = CheckpointLoaderSimple({
    ckpt_name: model1_name,
  });
  const [model2, clip2, vae2] = CheckpointLoaderSimple({
    ckpt_name: model2_name,
  });

  const dress_case = [
    "white yoga",
    "black office",
    "pink sportswear",
    "cosplay",
  ];

  const generate_pipeline = (model, clip, vae, pos, neg) => {
    const [latent_image] = EmptyLatentImage({
      width: 640,
      height: 960,
      batch_size: 1,
    });
    const [positive] = CLIPTextEncode({ text: pos, clip });
    const [negative] = CLIPTextEncode({ text: neg, clip });
    const [samples] = KSampler({
      ...sampler_settings,
      model,
      positive,
      negative,
      latent_image,
    });
    const [image] = VAEDecode({ samples, vae });
    return image;
  };

  for (const cloth of dress_case) {
    const input_pos = `${pos}, ${cloth} dress`;
    const image = generate_pipeline(model1, clip1, vae1, input_pos, neg);
    SaveImage({
      images: image,
      filename_prefix: `${cloth}-lofi-v5`,
    });

    const input_pos2 = `${pos}, ${cloth} dress`;
    const image2 = generate_pipeline(model2, clip2, vae2, input_pos2, neg);
    SaveImage({
      images: image2,
      filename_prefix: `${cloth}-case-h-beta`,
    });
  }

  return workflow;
 * ```
 */
declare class ComfyUIWorkflow {
    protected _workflow: IWorkflow;
    protected _last_node_id: number;
    classes: BuiltinNodeClasses & Record<string, ComfyUINodeClass<NodeClassInputs>>;
    protected _createClassesProxy(): BuiltinNodeClasses & Record<string, ComfyUINodeClass<NodeClassInputs>>;
    /**
     * Resets the workflow by clearing the prompt and setting the workflow to undefined.
     */
    reset(): void;
    /**
     * Returns the current workflow object.
     *
     * @return {IWorkflow} The current workflow object.
     *
     * @deprecated use `workflow` instead
     */
    end(): IWorkflow;
    /**
     * Returns the current workflow object.
     *
     * @return {IWorkflow} The current workflow object.
     */
    workflow(): IWorkflow;
    /**
     * Invoke this workflow using the provided client.
     *
     * @param {ComfyUIApiClient} client - The client used to run the prompt.
     * @return {Promise<WorkflowOutput>} A promise that resolves with the result of the prompt.
     */
    invoke(client: ComfyUIApiClient): Promise<WorkflowOutput>;
    /**
     * Creates a new invoked workflow instance.
     *
     * @param {ComfyUIApiClient} client - The client used to run the prompt.
     * @return {InvokedWorkflow} The invoked workflow instance.
     */
    instance(client: ComfyUIApiClient): InvokedWorkflow;
    /**
     * Invokes the workflow using the provided client with polling.
     *
     * @param {ComfyUIApiClient} client - The client used to run the prompt.
     * @return {Promise<WorkflowOutput>} A promise that resolves with the result of the prompt.
     */
    invoke_polling(client: ComfyUIApiClient): Promise<WorkflowOutput>;
}

/**
 * Provide api-auth support for this https://github.com/liusida/ComfyUI-Login/tree/main extension
 */
declare class LoginAuthPlugin extends ClientPlugin {
    readonly options: {
        token: string;
    };
    constructor(options: {
        token: string;
    });
}

export { ClientPlugin, ComfyUIApiClient, ComfyUIWorkflow, ComfyUIWsClient, type IComfyApiConfig, type IWorkflow, LoginAuthPlugin, type WorkflowOutput, type WorkflowPromptNode };
